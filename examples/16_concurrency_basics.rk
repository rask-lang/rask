// SPDX-License-Identifier: (MIT OR Apache-2.0)
// Learn: Concurrency with threads and channels

func worker(id: i32, iterations: i32) -> i32 {
    print("Worker ")
    print(id)
    print(" starting\n")

    let sum = 0
    for i in 1..iterations + 1 {
        sum = sum + i
    }

    print("Worker ")
    print(id)
    print(" done, sum = ")
    print(sum)
    print("\n")

    return sum
}

func main() -> () or string {
    print("=== Basic Threading ===\n\n")

    // Spawn a thread with spawn raw { }
    // Returns a ThreadHandle
    const handle = spawn raw {
        print("Hello from thread!\n")
        return 42
    }

    print("Main thread continues...\n")

    // Wait for thread to complete with .join()
    const result = try handle.join()
    print("Thread returned: ")
    print(result)
    print("\n\n")

    // Spawn multiple threads
    print("=== Multiple Threads ===\n\n")

    const h1 = spawn raw { return worker(1, 10) }
    const h2 = spawn raw { return worker(2, 20) }
    const h3 = spawn raw { return worker(3, 15) }

    // Wait for all threads
    const r1 = try h1.join()
    const r2 = try h2.join()
    const r3 = try h3.join()

    const total = r1 + r2 + r3
    print("\nTotal: ")
    print(total)
    print("\n\n")

    // Detaching threads - fire and forget
    print("=== Detached Threads ===\n\n")

    const detached = spawn raw {
        print("I'm a detached thread!\n")
        return 0
    }

    detached.detach()  // Don't wait for it
    print("Detached thread running in background\n\n")

    // Channels for communication
    print("=== Channels ===\n\n")

    const channel = Channel.buffered<string>(5)

    // Spawn producer thread
    const producer = spawn raw {
        try channel.sender.send("Message 1")
        try channel.sender.send("Message 2")
        try channel.sender.send("Message 3")
        print("Producer sent 3 messages\n")
        return 0
    }

    // Spawn consumer thread
    const consumer = spawn raw {
        const msg1 = try channel.receiver.recv()
        print("Received: ")
        print(msg1)
        print("\n")

        const msg2 = try channel.receiver.recv()
        print("Received: ")
        print(msg2)
        print("\n")

        const msg3 = try channel.receiver.recv()
        print("Received: ")
        print(msg3)
        print("\n")

        return 0
    }

    try producer.join()
    try consumer.join()
    print("\n")

    // Unbuffered channel - synchronous
    print("=== Unbuffered Channel ===\n\n")

    const sync_channel = Channel.unbuffered<i32>()

    const sender_thread = spawn raw {
        print("Sending 100...\n")
        try sync_channel.sender.send(100)  // Blocks until received
        print("Send complete\n")
        return 0
    }

    const receiver_thread = spawn raw {
        print("Waiting to receive...\n")
        const value = try sync_channel.receiver.recv()  // Blocks until sent
        print("Received: ")
        print(value)
        print("\n")
        return 0
    }

    try sender_thread.join()
    try receiver_thread.join()
    print("\n")

    // Try receive - non-blocking
    print("=== Non-blocking Receive ===\n\n")

    const test_channel = Channel.buffered<i32>(2)

    // Send one message
    try test_channel.sender.send(999)

    // Try to receive
    const maybe_msg = test_channel.receiver.try_recv()

    match maybe_msg {
        Ok(value) => {
            print("Got message: ")
            print(value)
            print("\n")
        }
        Err(e) => {
            print("No message available\n")
        }
    }

    // Try to receive again (should fail, channel empty)
    const no_msg = test_channel.receiver.try_recv()

    match no_msg {
        Ok(value) => {
            print("Got message: ")
            print(value)
            print("\n")
        }
        Err(e) => {
            print("Channel empty (expected)\n")
        }
    }

    print("\n")

    // Thread pool
    print("=== Thread Pool ===\n\n")

    using ThreadPool(workers: 4) {
        const handles = Vec.new()

        for i in 0..8 {
            const h = spawn thread {
                print("Pool task ")
                print(i)
                print(" running\n")
                return i * i
            }
            handles.push(h)
        }

        print("\nWaiting for all pool tasks...\n")

        for handle in handles.iter() {
            const res = try handle.join()
            print("Task result: ")
            print(res)
            print("\n")
        }
    }

    print("\n=== Key Points ===\n")
    print("- spawn raw { } creates raw OS threads\n")
    print("- spawn thread { } uses thread pool (needs using ThreadPool)\n")
    print("- handle.join() waits for completion\n")
    print("- handle.detach() runs in background\n")
    print("- Channels enable message passing\n")
    print("- No data races - compiler enforces safety\n")
    print("- No function coloring - threads are first-class\n")

    return Ok(())
}
