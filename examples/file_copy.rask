// SPDX-License-Identifier: (MIT OR Apache-2.0)
// File Copy Utility
// Demonstrates: CLI arg parsing, structs, enums, match, error propagation,
//               closures (map_err), string interpolation, file I/O

import fs
import cli
import std

enum CopyError {
    SourceNotFound(string),
    DestinationExists(string),
    ReadError(string),
    WriteError(string),
    SameFile,
}

extend CopyError {
    func message(self) -> string {
        match self {
            SourceNotFound(path) => return "source file not found: {path}",
            DestinationExists(path) => return "destination already exists: {path} (use -f to overwrite)",
            ReadError(msg) => return "read error: {msg}",
            WriteError(msg) => return "write error: {msg}",
            SameFile => return "source and destination are the same file",
        }
    }
}

struct CopyOptions {
    source: string
    dest: string
    force: bool
    verbose: bool
}

func parse_args(args: Vec<string>) -> CopyOptions or string {
    let opts = CopyOptions {
        source: "",
        dest: "",
        force: false,
        verbose: false,
    }

    let positional = Vec.new()

    for arg in args.iter().skip(1) {
        match arg {
            "-f" | "--force" => opts.force = true,
            "-v" | "--verbose" => opts.verbose = true,
            "-h" | "--help" => {
                print_usage()
                std.exit(0)
            }
            _ => positional.push(arg.clone()),
        }
    }

    if positional.len() < 2 {
        return Err("usage: rcopy [-fv] SOURCE DEST")
    }

    opts.source = positional[0].clone()
    opts.dest = positional[1].clone()

    return Ok(opts)
}

func print_usage() {
    println("Usage: rcopy [OPTIONS] SOURCE DEST")
    println("")
    println("Copy SOURCE to DEST")
    println("")
    println("Options:")
    println("  -f, --force     Overwrite destination if it exists")
    println("  -v, --verbose   Show progress information")
    println("  -h, --help      Show this help")
}

func copy_file(opts: CopyOptions) -> i64 or CopyError {
    // Check source exists
    if !fs.exists(opts.source.clone()) {
        return Err(CopyError.SourceNotFound(opts.source))
    }

    // Check destination
    if fs.exists(opts.dest.clone()) {
        if !opts.force {
            return Err(CopyError.DestinationExists(opts.dest))
        }
    }

    // Check not same file (using canonical paths)
    const src_canonical = try fs.canonicalize(opts.source.clone())
        .map_err(|e| CopyError.ReadError(e))
    const dst_canonical = fs.canonicalize(opts.dest.clone()).ok()

    if dst_canonical is Some(dst) {
        if src_canonical == dst {
            return Err(CopyError.SameFile)
        }
    }

    // Copy the file
    const bytes = try fs.copy(opts.source.clone(), opts.dest.clone())
        .map_err(|e| CopyError.WriteError(e))

    return Ok(bytes)
}

func format_size(bytes: i64) -> string {
    if bytes < 1024 {
        return "{bytes} B"
    } else if bytes < 1048576 {
        const kb = bytes / 1024
        return "{kb} KB"
    } else {
        const mb = bytes / 1048576
        return "{mb} MB"
    }
}

@entry
func main() {
    const args = cli.args()

    const opts = match parse_args(args) {
        Ok(o) => o,
        Err(msg) => {
            println("rcopy: {msg}")
            std.exit(1)
        }
    }

    if opts.verbose {
        println("Copying '{opts.source}' to '{opts.dest}'...")
    }

    match copy_file(opts.clone()) {
        Ok(bytes) => {
            if opts.verbose {
                const size = format_size(bytes)
                println("Copied {size}")
            }
        }
        Err(e) => {
            const msg = e.message()
            println("rcopy: {msg}")
            std.exit(1)
        }
    }
}
