// SPDX-License-Identifier: (MIT OR Apache-2.0)
import io

// CLI Calculator - Expression Evaluator
// Demonstrates: Parsing, enums, match expressions, error handling, REPL pattern

// Token types from lexer
enum Token {
    Number(f64),
    Plus,
    Minus,
    Star,
    Slash,
    Percent,
    Caret,       // Power
    LParen,
    RParen,
    Eof,
}

// AST nodes
enum Expr {
    Number(f64),
    Binary(left: Owned<Expr>, op: BinaryOp, right: Owned<Expr>),
    Unary(op: UnaryOp, expr: Owned<Expr>),
}

enum BinaryOp {
    Add,
    Sub,
    Mul,
    Div,
    Mod,
    Pow,
}

enum UnaryOp {
    Neg,
}

enum CalcError {
    UnexpectedChar(char),
    UnexpectedToken(string),
    DivisionByZero,
    EmptyExpression,
}

extend CalcError {
    func message(self) -> string {
        match self {
            UnexpectedChar(c) => return "unexpected character: '{c}'",
            UnexpectedToken(s) => return "unexpected token: {s}",
            DivisionByZero => return "division by zero",
            EmptyExpression => return "empty expression",
        }
    }
}

// Lexer
struct Lexer {
    input: string
    pos: usize
}

extend Lexer {
    func new(input: string) -> Lexer {
        return Lexer { input: input, pos: 0 as usize }
    }

    func peek_char(self) -> char? {
        if self.pos >= self.input.len(): return None
        self.input.char_at(self.pos)
    }

    func advance(self) -> char? {
        const c = try self.peek_char()
        self.pos += 1
        Some(c)
    }

    func skip_whitespace(self) {
        while self.peek_char() is Some(c) {
            if !c.is_whitespace(): break
            self.advance()
        }
    }

    func next_token(self) -> Token or CalcError {
        self.skip_whitespace()

        const c = match self.peek_char() {
            Some(c) => c,
            None => return Ok(Token.Eof),
        }

        // Single-character tokens
        const token = match c {
            '+' => { self.advance(); Token.Plus }
            '-' => { self.advance(); Token.Minus }
            '*' => { self.advance(); Token.Star }
            '/' => { self.advance(); Token.Slash }
            '%' => { self.advance(); Token.Percent }
            '^' => { self.advance(); Token.Caret }
            '(' => { self.advance(); Token.LParen }
            ')' => { self.advance(); Token.RParen }
            _ if c.is_digit() || c == '.' => try self.read_number(),
            _ => return Err(CalcError.UnexpectedChar(c)),
        }

        Ok(token)
    }

    func read_number(self) -> Token or CalcError {
        const num_str = string.new()
        let has_dot = false

        while self.peek_char() is Some(c) {
            if c.is_digit() {
                num_str.push(c)
                self.advance()
            } else if c == '.' && !has_dot {
                has_dot = true
                num_str.push(c)
                self.advance()
            } else {
                break
            }
        }

        const value: f64 = num_str.parse().unwrap()
        Ok(Token.Number(value))
    }
}

// Parser with operator precedence
struct Parser {
    lexer: Lexer
    current: Token
}

extend Parser {
    func new(input: string) -> Parser or CalcError {
        const lexer = Lexer.new(input)
        const current = try lexer.next_token()
        Ok(Parser { lexer: lexer, current: current })
    }

    func advance(self) -> () or CalcError {
        self.current = try self.lexer.next_token()
    }

    func parse(self) -> Expr or CalcError {
        const expr = try self.parse_expression()

        match self.current {
            Eof => return Ok(expr),
            _ => return Err(CalcError.UnexpectedToken(self.token_string())),
        }
    }
    

    func token_string(self) -> string {
        match self.current {
            Number(n) => return "{n}",
            Plus => return "+",
            Minus => return "-",
            Star => return "*",
            Slash => return "/",
            Percent => return "%",
            Caret => return "^",
            LParen => return "(",
            RParen => return ")",
            Eof => return "end of input",
        }
    }

    // expression = term (('+' | '-') term)*
    func parse_expression(self) -> Expr or CalcError {
        let left = try self.parse_term()

        loop {
            const op = match self.current {
                Plus => BinaryOp.Add,
                Minus => BinaryOp.Sub,
                _ => break,
            }
            try self.advance()
            const right = try self.parse_term()
            left = Expr.Binary(left: own left, op: op, right: own right)
        }

        Ok(left)
    }

    // term = power (('*' | '/' | '%') power)*
    func parse_term(self) -> Expr or CalcError {
        let left = try self.parse_power()

        loop {
            const op = match self.current {
                Star => BinaryOp.Mul,
                Slash => BinaryOp.Div,
                Percent => BinaryOp.Mod,
                _ => break,
            }
            try self.advance()
            const right = try self.parse_power()
            left = Expr.Binary(left: own left, op: op, right: own right)
        }

        Ok(left)
    }

    // power = unary ('^' power)?  (right associative)
    func parse_power(self) -> Expr or CalcError {
        const base = try self.parse_unary()

        if self.current is Caret {
            try self.advance()
            const exp = try self.parse_power()  // Right associative
            return Ok(Expr.Binary(left: own base, op: BinaryOp.Pow, right: own exp))
        } else {
            return Ok(base)
        }
    }

    // unary = '-' unary | primary
    func parse_unary(self) -> Expr or CalcError {
        if self.current is Minus {
            try self.advance()
            const expr = try self.parse_unary()
            return Ok(Expr.Unary(op: UnaryOp.Neg, expr: own expr))
        } else {
            return self.parse_primary()
        }
    }

    // primary = NUMBER | '(' expression ')'
    func parse_primary(self) -> Expr or CalcError {
        match self.current {
            Number(n) => {
                try self.advance()
                return Ok(Expr.Number(n))
            }
            LParen => {
                try self.advance()
                const expr = try self.parse_expression()
                match self.current {
                    RParen => {
                        try self.advance()
                        return Ok(expr)
                    }
                    _ => return Err(CalcError.UnexpectedToken("expected ')'".to_string())),
                }
            }
            Eof => return Err(CalcError.EmptyExpression),
            _ => return Err(CalcError.UnexpectedToken(self.token_string())),
        }
    }
}

// Evaluator
func evaluate(expr: Expr) -> f64 or CalcError {
    match expr {
        Number(n) => return Ok(n),
        Unary(op, inner) => {
            const val = try evaluate(inner)
            match op {
                Neg => return Ok(-val),
            }
        }
        Binary(left, op, right) => {
            const l = try evaluate(left)
            const r = try evaluate(right)
            match op {
                Add => return Ok(l + r),
                Sub => return Ok(l - r),
                Mul => return Ok(l * r),
                Div => {
                    if r == 0.0: return Err(CalcError.DivisionByZero)
                    return Ok(l / r)
                }
                Mod => {
                    if r == 0.0: return Err(CalcError.DivisionByZero)
                    return Ok(l % r)
                }
                Pow => return Ok(l.powf(r)),
            }
        }
    }
}

func calc(input: string) -> f64 or CalcError {
    const parser = try Parser.new(input)
    const expr = try parser.parse()
    evaluate(expr)
}

func print_help() {
    println("Calculator - Enter expressions to evaluate")
    println("")
    println("Operators:")
    println("  + - * /  Basic arithmetic")
    println("  %        Modulo")
    println("  ^        Power (right associative)")
    println("  ( )      Grouping")
    println("")
    println("Examples:")
    println("  2 + 3 * 4      => 14")
    println("  (2 + 3) * 4    => 20")
    println("  2 ^ 3 ^ 2      => 512 (right associative)")
    println("  -5 + 3         => -2")
    println("")
    println("Commands:")
    println("  help     Show this help")
    println("  quit     Exit calculator")
}

@entry
func main() -> () or Error {
    println("Rask Calculator")
    println("Type 'help' for usage, 'quit' to exit")
    println("")

    loop {
        print("> ")
        const input = (try io.read_line()).trim()

        if input.is_empty(): continue

        match input {
            "quit" | "exit" | "q" => break,
            "help" | "h" | "?" => print_help(),
            _ => {
                match calc(input.to_string()) {
                    Ok(result) => println("= {result}"),
                    Err(e) => println("Error: {e.message()}"),
                }
            }
        }
    }

    println("Goodbye!")
}

// ============================================================================
// Tests - Demonstrates test blocks and assert statements
// ============================================================================

test "addition" {
    assert calc("2 + 3") == Ok(5.0)
    assert calc("10 + 20 + 30") == Ok(60.0)
}

test "subtraction" {
    assert calc("10 - 3") == Ok(7.0)
    assert calc("5 - 10") == Ok(-5.0)
}

test "multiplication" {
    assert calc("4 * 5") == Ok(20.0)
    assert calc("2 * 3 * 4") == Ok(24.0)
}

test "division" {
    assert calc("20 / 4") == Ok(5.0)
    assert calc("7 / 2") == Ok(3.5)
}

test "precedence" {
    // Multiplication before addition
    assert calc("2 + 3 * 4") == Ok(14.0)
    assert calc("2 * 3 + 4") == Ok(10.0)

    // Division before subtraction
    assert calc("10 - 6 / 2") == Ok(7.0)
}

test "parentheses" {
    assert calc("(2 + 3) * 4") == Ok(20.0)
    assert calc("2 * (3 + 4)") == Ok(14.0)
    assert calc("((1 + 2) * (3 + 4))") == Ok(21.0)
}

test "power right associative" {
    // 2^3^2 = 2^(3^2) = 2^9 = 512, not (2^3)^2 = 64
    assert calc("2 ^ 3 ^ 2") == Ok(512.0)
    assert calc("2 ^ 3") == Ok(8.0)
}

test "unary negation" {
    assert calc("-5") == Ok(-5.0)
    assert calc("-5 + 3") == Ok(-2.0)
    assert calc("--5") == Ok(5.0)  // Double negation
    assert calc("3 * -2") == Ok(-6.0)
}

test "modulo" {
    assert calc("10 % 3") == Ok(1.0)
    assert calc("15 % 4") == Ok(3.0)
}

test "floating point" {
    assert calc("3.14 * 2") == Ok(6.28)
    assert calc("1.5 + 2.5") == Ok(4.0)
}

test "division by zero" {
    assert calc("5 / 0") == Err(CalcError.DivisionByZero)
    assert calc("10 % 0") == Err(CalcError.DivisionByZero)
}

test "invalid input" {
    assert calc("2 +").is_err()
    assert calc("") == Err(CalcError.EmptyExpression)
    assert calc("@").is_err()
}
