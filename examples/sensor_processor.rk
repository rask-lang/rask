// SPDX-License-Identifier: (MIT OR Apache-2.0)
// Embedded Sensor Processor
// Demonstrates: Threading, timing, struct methods, match, real-time deadlines

import thread.Thread
import time

// ============================================================================
// Lookup Tables (runtime-initialized)
// ============================================================================

func build_crc8_table() -> Vec<i64> {
    const table = Vec.new()
    for i in 0..256 {
        let crc = i
        for j in 0..8 {
            if crc & 128 != 0 {
                crc = ((crc * 2) & 255) ^ 7
            } else {
                crc = (crc * 2) & 255
            }
        }
        table.push(crc)
    }
    return table
}

func crc8(data: Vec<i64>, table: Vec<i64>) -> i64 {
    let crc: i64 = 0
    const n = data.len()
    for i in 0..n {
        const byte = data.get(i).unwrap()
        crc = table.get((crc ^ byte) & 255).unwrap()
    }
    return crc
}

// Read from simulated hardware register
func read_hardware_sensor(sensor_id: i64, tick: i64) -> f64 {
    const base = match sensor_id {
        0 => 2200,
        1 => 10130,
        2 => 4500,
        _ => 0,
    }

    const noise = ((tick * 7 + sensor_id * 13) % 100) - 50
    return (base + noise) as f64 / 100.0
}

// ============================================================================
// Timing Statistics
// ============================================================================

struct TimingStats {
    samples: Vec<i64>
    sample_idx: i64
    sample_count: i64
    min_ns: i64
    max_ns: i64
    sum_ns: i64
    deadline_misses: i64
}

extend TimingStats {
    func record(self, cycle_ns: i64, deadline_ns: i64) {
        self.samples.set(self.sample_idx, cycle_ns)
        self.sample_idx = (self.sample_idx + 1) % 256

        if self.sample_count < 256 {
            self.sample_count += 1
        }
        if cycle_ns < self.min_ns {
            self.min_ns = cycle_ns
        }
        if cycle_ns > self.max_ns {
            self.max_ns = cycle_ns
        }
        self.sum_ns += cycle_ns

        if cycle_ns > deadline_ns {
            self.deadline_misses += 1
        }
    }

    func mean_ns(self) -> i64 {
        if self.sample_count == 0 {
            return 0
        }
        return self.sum_ns / self.sample_count
    }
}

// Integer square root
func isqrt(n: i64) -> i64 {
    if n == 0 {
        return 0
    }
    let x = n
    let y = (x + 1) / 2
    while y < x {
        x = y
        y = (x + n / x) / 2
    }
    return x
}

// ============================================================================
// Interrupt Handler Simulation (runs on separate thread)
// ============================================================================

// Pushes sensor readings into a shared Vec. The Vec handle is heap-allocated,
// so the main thread sees appended data via its own copy of the handle.
func interrupt_handler(
    readings: Vec<i64>,
    start_time: time.Instant,
    sample_rate_hz: i64
) {
    const period_ns = 1000000000 / sample_rate_hz
    let sequence: i64 = 0

    while sequence < sample_rate_hz * 2 {
        const now_ns = time.Instant.now().duration_since(start_time).as_nanos() as i64

        for sensor_id in 0..3 {
            const value = read_hardware_sensor(sensor_id, sequence)
            // Encode reading as 3 consecutive i64s: sensor_id, value bits, timestamp
            readings.push(sensor_id)
            readings.push(value as i64)
            readings.push(now_ns)
        }

        sequence += 1
        time.sleep(time.Duration.from_millis(period_ns / 1000000))
    }
}

// ============================================================================
// Processing State
// ============================================================================

struct ProcessorState {
    temp_history: Vec<f64>
    pressure_history: Vec<f64>
    humidity_history: Vec<f64>
    history_idx: i64
    history_count: i64
    temp_avg: f64
    pressure_avg: f64
    humidity_avg: f64
    samples_processed: i64
}

extend ProcessorState {
    func process_reading(self, sensor_id: i64, value: f64) {
        match sensor_id {
            0 => self.temp_history.set(self.history_idx, value),
            1 => self.pressure_history.set(self.history_idx, value),
            2 => self.humidity_history.set(self.history_idx, value),
            _ => {}
        }

        if sensor_id == 2 {
            self.history_idx = (self.history_idx + 1) % 64
            if self.history_count < 64 {
                self.history_count += 1
            }
        }

        self.samples_processed += 1
    }

    func compute_averages(self) {
        if self.history_count == 0 {
            return
        }

        let temp_sum = 0.0
        let pres_sum = 0.0
        let hum_sum = 0.0
        for i in 0..self.history_count {
            temp_sum += self.temp_history.get(i).unwrap()
            pres_sum += self.pressure_history.get(i).unwrap()
            hum_sum += self.humidity_history.get(i).unwrap()
        }

        const n = self.history_count as f64
        self.temp_avg = temp_sum / n
        self.pressure_avg = pres_sum / n
        self.humidity_avg = hum_sum / n
    }
}

// ============================================================================
// Main Entry Point
// ============================================================================

func main() {
    println("=== Real-Time Sensor Processor ===")
    println("")

    const SAMPLE_RATE_HZ = 1000
    const PROCESS_RATE_HZ = 100
    const HARD_DEADLINE_US = 5000
    const DURATION_SECS = 2

    println("Sample rate: {SAMPLE_RATE_HZ} Hz (interrupt)")
    println("Process rate: {PROCESS_RATE_HZ} Hz (main loop)")
    println("Hard deadline: {HARD_DEADLINE_US} µs")
    println("")

    // Build lookup tables
    const crc_table = build_crc8_table()

    // Shared buffer: interrupt handler appends, main thread reads.
    // Vec handles are heap-allocated — both threads see the same data.
    const readings = Vec.new()

    const temp_hist = Vec.new()
    const pres_hist = Vec.new()
    const hum_hist = Vec.new()
    for i in 0..64 {
        temp_hist.push(0.0)
        pres_hist.push(0.0)
        hum_hist.push(0.0)
    }
    let state = ProcessorState {
        temp_history: temp_hist,
        pressure_history: pres_hist,
        humidity_history: hum_hist,
        history_idx: 0,
        history_count: 0,
        temp_avg: 0.0,
        pressure_avg: 0.0,
        humidity_avg: 0.0,
        samples_processed: 0,
    }

    const timing_samples = Vec.new()
    for i in 0..256 {
        timing_samples.push(0)
    }
    let timing = TimingStats {
        samples: timing_samples,
        sample_idx: 0,
        sample_count: 0,
        min_ns: 9999999999,
        max_ns: 0,
        sum_ns: 0,
        deadline_misses: 0,
    }

    const start_time = time.Instant.now()
    const process_period_ns = 1000000000 / PROCESS_RATE_HZ
    const deadline_ns = HARD_DEADLINE_US * 1000

    // Start interrupt handler on separate thread
    let isr_handle = Thread.spawn(|| {
        interrupt_handler(readings, start_time, SAMPLE_RATE_HZ)
    })

    println("Started. Processing for {DURATION_SECS} seconds...")
    println("")

    let cycle: i64 = 0
    let read_idx: i64 = 0

    while (time.Instant.now().duration_since(start_time).as_secs() as i64) < DURATION_SECS {
        const cycle_start = time.Instant.now()

        // Drain available samples — each reading is 3 consecutive i64s
        while read_idx + 2 < readings.len() {
            const sensor_id = readings.get(read_idx).unwrap()
            const value_bits = readings.get(read_idx + 1).unwrap()
            const value = value_bits as f64
            read_idx += 3
            state.process_reading(sensor_id, value)
        }

        // Compute derived values periodically
        if cycle % 10 == 0 {
            state.compute_averages()
        }

        // Measure cycle time
        const cycle_ns = cycle_start.elapsed().as_nanos() as i64
        timing.record(cycle_ns, deadline_ns)

        cycle += 1

        // Sleep until next cycle
        time.sleep(time.Duration.from_millis(process_period_ns / 1000000))
    }

    // Wait for interrupt handler
    isr_handle.join()

    // Print results
    println("=== Results ===")
    println("")
    println("Samples processed: {state.samples_processed}")
    println("Processing cycles: {cycle}")
    println("")
    const min_us = timing.min_ns / 1000
    const max_us = timing.max_ns / 1000
    const mean_us = timing.mean_ns() / 1000
    println("Timing Statistics:")
    println("  Min cycle:  {min_us} µs")
    println("  Max cycle:  {max_us} µs")
    println("  Mean cycle: {mean_us} µs")
    println("  Deadline misses: {timing.deadline_misses}")
    println("")
    println("Final Averages (64-sample window):")
    println("  Temperature: {state.temp_avg} C")
    println("  Pressure:    {state.pressure_avg} hPa")
    println("  Humidity:    {state.humidity_avg} %")

    if timing.deadline_misses > 0 {
        println("")
        println("WARNING: {timing.deadline_misses} deadline misses detected!")
    }
}
