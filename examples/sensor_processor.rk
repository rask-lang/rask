// SPDX-License-Identifier: (MIT OR Apache-2.0)
// Embedded Sensor Processor
// Demonstrates: Threading, timing, struct methods, match, real-time deadlines

import thread.Thread
import time

// ============================================================================
// SPSC Ring Buffer (concrete, Vec-backed)
// ============================================================================

struct SensorRingBuffer {
    data: Vec<SensorReading>
    capacity: i64
    write_idx: i64
    read_idx: i64
}

extend SensorRingBuffer {
    func new(capacity: i64) -> SensorRingBuffer {
        const data = Vec.new()
        for i in 0..capacity {
            data.push(SensorReading {
                sensor_id: 0,
                value: 0.0,
                timestamp_ns: 0,
            })
        }
        return SensorRingBuffer {
            data: data,
            capacity: capacity,
            write_idx: 0,
            read_idx: 0,
        }
    }

    func try_push(self, value: SensorReading) -> bool {
        const next_write = (self.write_idx + 1) % self.capacity
        if next_write == self.read_idx {
            return false
        }
        self.data.set(self.write_idx, value)
        self.write_idx = next_write
        return true
    }

    func has_data(self) -> bool {
        return self.read_idx != self.write_idx
    }

    func pop(self) -> SensorReading {
        const idx = self.read_idx
        self.read_idx = (self.read_idx + 1) % self.capacity
        return self.data.get(idx).unwrap()
    }

    func len(self) -> i64 {
        if self.write_idx >= self.read_idx {
            return self.write_idx - self.read_idx
        }
        return self.capacity - self.read_idx + self.write_idx
    }
}

// ============================================================================
// Sensor Reading
// ============================================================================

struct SensorReading {
    sensor_id: i64
    value: f64
    timestamp_ns: i64
}

// ============================================================================
// Lookup Tables (runtime-initialized)
// ============================================================================

func build_crc8_table() -> Vec<i64> {
    const table = Vec.new()
    for i in 0..256 {
        let crc = i
        for j in 0..8 {
            if crc & 128 != 0 {
                crc = ((crc * 2) & 255) ^ 7
            } else {
                crc = (crc * 2) & 255
            }
        }
        table.push(crc)
    }
    return table
}

func crc8(data: Vec<i64>, table: Vec<i64>) -> i64 {
    let crc: i64 = 0
    const n = data.len()
    for i in 0..n {
        const byte = data.get(i).unwrap()
        crc = table.get((crc ^ byte) & 255).unwrap()
    }
    return crc
}

// Read from simulated hardware register
func read_hardware_sensor(sensor_id: i64, tick: i64) -> f64 {
    const base = match sensor_id {
        0 => 2200,
        1 => 10130,
        2 => 4500,
        _ => 0,
    }

    const noise = ((tick * 7 + sensor_id * 13) % 100) - 50
    return (base + noise) as f64 / 100.0
}

// ============================================================================
// Timing Statistics
// ============================================================================

struct TimingStats {
    samples: Vec<i64>
    sample_idx: i64
    sample_count: i64
    min_ns: i64
    max_ns: i64
    sum_ns: i64
    deadline_misses: i64
}

extend TimingStats {
    func new() -> TimingStats {
        const samples = Vec.new()
        for i in 0..256 {
            samples.push(0)
        }
        return TimingStats {
            samples: samples,
            sample_idx: 0,
            sample_count: 0,
            min_ns: 9999999999,
            max_ns: 0,
            sum_ns: 0,
            deadline_misses: 0,
        }
    }

    func record(self, cycle_ns: i64, deadline_ns: i64) {
        self.samples.set(self.sample_idx, cycle_ns)
        self.sample_idx = (self.sample_idx + 1) % 256

        if self.sample_count < 256 {
            self.sample_count += 1
        }
        if cycle_ns < self.min_ns {
            self.min_ns = cycle_ns
        }
        if cycle_ns > self.max_ns {
            self.max_ns = cycle_ns
        }
        self.sum_ns += cycle_ns

        if cycle_ns > deadline_ns {
            self.deadline_misses += 1
        }
    }

    func mean_ns(self) -> i64 {
        if self.sample_count == 0 {
            return 0
        }
        return self.sum_ns / self.sample_count
    }
}

// Integer square root
func isqrt(n: i64) -> i64 {
    if n == 0 {
        return 0
    }
    let x = n
    let y = (x + 1) / 2
    while y < x {
        x = y
        y = (x + n / x) / 2
    }
    return x
}

// ============================================================================
// Interrupt Handler Simulation (runs on separate thread)
// ============================================================================

func interrupt_handler(
    buffer: SensorRingBuffer,
    start_time: time.Instant,
    sample_rate_hz: i64
) {
    const period_ns = 1000000000 / sample_rate_hz
    let sequence: i64 = 0

    // Run for limited iterations (simulates timed interrupt)
    while sequence < sample_rate_hz * 2 {
        const now_ns = time.Instant.now().duration_since(start_time).as_nanos() as i64

        for sensor_id in 0..3 {
            const reading = SensorReading {
                sensor_id: sensor_id,
                value: read_hardware_sensor(sensor_id, sequence),
                timestamp_ns: now_ns,
            }

            if !buffer.try_push(own reading) {
                // Buffer overflow
            }
        }

        sequence += 1
        time.sleep(period_ns / 1000000)
    }
}

// ============================================================================
// Main Processing Loop
// ============================================================================

struct ProcessorState {
    temp_history: Vec<f64>
    pressure_history: Vec<f64>
    humidity_history: Vec<f64>
    history_idx: i64
    history_count: i64

    temp_avg: f64
    pressure_avg: f64
    humidity_avg: f64

    samples_processed: i64
}

extend ProcessorState {
    func new() -> ProcessorState {
        const temp = Vec.new()
        const pres = Vec.new()
        const hum = Vec.new()
        for i in 0..64 {
            temp.push(0.0)
            pres.push(0.0)
            hum.push(0.0)
        }
        return ProcessorState {
            temp_history: temp,
            pressure_history: pres,
            humidity_history: hum,
            history_idx: 0,
            history_count: 0,
            temp_avg: 0.0,
            pressure_avg: 0.0,
            humidity_avg: 0.0,
            samples_processed: 0,
        }
    }

    func process_reading(self, reading: SensorReading) {
        match reading.sensor_id {
            0 => self.temp_history.set(self.history_idx, reading.value),
            1 => self.pressure_history.set(self.history_idx, reading.value),
            2 => self.humidity_history.set(self.history_idx, reading.value),
            _ => {}
        }

        if reading.sensor_id == 2 {
            self.history_idx = (self.history_idx + 1) % 64
            if self.history_count < 64 {
                self.history_count += 1
            }
        }

        self.samples_processed += 1
    }

    func compute_averages(self) {
        if self.history_count == 0 {
            return
        }

        let temp_sum = 0.0
        let pres_sum = 0.0
        let hum_sum = 0.0
        for i in 0..self.history_count {
            temp_sum += self.temp_history.get(i).unwrap()
            pres_sum += self.pressure_history.get(i).unwrap()
            hum_sum += self.humidity_history.get(i).unwrap()
        }

        const n = self.history_count as f64
        self.temp_avg = temp_sum / n
        self.pressure_avg = pres_sum / n
        self.humidity_avg = hum_sum / n
    }
}

// Scalar array sum (replaces SIMD version)
func array_sum(data: Vec<f64>, count: i64) -> f64 {
    let sum = 0.0
    for i in 0..count {
        sum += data.get(i).unwrap()
    }
    return sum
}

// ============================================================================
// Main Entry Point
// ============================================================================

func main() -> () or Error {
    println("=== Real-Time Sensor Processor ===")
    println("")

    const SAMPLE_RATE_HZ = 1000
    const PROCESS_RATE_HZ = 100
    const HARD_DEADLINE_US = 5000
    const DURATION_SECS = 2

    println("Sample rate: {SAMPLE_RATE_HZ} Hz (interrupt)")
    println("Process rate: {PROCESS_RATE_HZ} Hz (main loop)")
    println("Hard deadline: {HARD_DEADLINE_US} µs")
    println("")

    // Build lookup tables
    const crc_table = build_crc8_table()

    // Pre-allocate everything
    let buffer = SensorRingBuffer.new(256)
    let state = ProcessorState.new()
    let timing = TimingStats.new()

    const start_time = time.Instant.now()
    const process_period_ns = 1000000000 / PROCESS_RATE_HZ
    const deadline_ns = HARD_DEADLINE_US * 1000

    // Start interrupt handler on separate thread
    let isr_handle = Thread.spawn(|| {
        interrupt_handler(buffer, start_time, SAMPLE_RATE_HZ)
    })

    println("Started. Processing for {DURATION_SECS} seconds...")
    println("")

    let cycle: i64 = 0

    while (time.Instant.now().duration_since(start_time).as_secs() as i64) < DURATION_SECS {
        const cycle_start = time.Instant.now()

        // Drain available samples from buffer
        let drained = 0
        while buffer.has_data() {
            const reading = buffer.pop()
            state.process_reading(reading)
            drained += 1
        }

        // Compute derived values periodically
        if cycle % 10 == 0 {
            state.compute_averages()
        }

        // Measure cycle time
        const cycle_ns = cycle_start.elapsed().as_nanos() as i64
        timing.record(cycle_ns, deadline_ns)

        cycle += 1

        // Sleep until next cycle
        time.sleep(time.Duration.from_millis(process_period_ns / 1000000))
    }

    // Wait for interrupt handler
    try isr_handle.join()

    // Print results
    println("=== Results ===")
    println("")
    println("Samples processed: {state.samples_processed}")
    println("Processing cycles: {cycle}")
    println("")
    println("Timing Statistics:")
    println("  Min cycle:  {timing.min_ns / 1000} µs")
    println("  Max cycle:  {timing.max_ns / 1000} µs")
    println("  Mean cycle: {timing.mean_ns() / 1000} µs")
    println("  Deadline misses: {timing.deadline_misses}")
    println("")
    println("Final Averages (64-sample window):")
    println("  Temperature: {state.temp_avg} C")
    println("  Pressure:    {state.pressure_avg} hPa")
    println("  Humidity:    {state.humidity_avg} %")

    if timing.deadline_misses > 0 {
        println("")
        println("WARNING: {timing.deadline_misses} deadline misses detected!")
    }

    Ok(())
}
