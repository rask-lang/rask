// SPDX-License-Identifier: (MIT OR Apache-2.0)
// Game Loop with Entities
// Demonstrates: Pool pattern, handle-based refs, traits, threading, time/delta, game systems

import time
import random

// Trait for updatable components
trait Updatable {
    func update(self, dt: f32)
}

// Position implements Updatable (applies velocity)
extend Position with Updatable {
    func update(self, dt: f32) {
        // Position updated by movement system
    }
}

// Component types
struct Position {
    x: f32
    y: f32
}

struct Velocity {
    dx: f32
    dy: f32
}

struct Health {
    current: i32
    max: i32
}

struct Collider {
    radius: f32
}

// Entity with all components
struct Entity {
    position: Position
    velocity: Velocity
    health: Health
    collider: Collider
    active: bool
    entity_type: EntityType
}

enum EntityType {
    Player,
    Enemy,
    Projectile,
}

// Game state
struct GameState {
    entities: Pool<Entity>
    player: Handle<Entity>?
    score: i32
    game_over: bool
}

extend GameState {
    func new() -> GameState or Error {
        let entities = Pool.new()

        // Spawn player at center
        const player_handle = try entities.insert(Entity {
            position: Position { x: 400.0f32, y: 300.0f32 },
            velocity: Velocity { dx: 0.0f32, dy: 0.0f32 },
            health: Health { current: 100, max: 100 },
            collider: Collider { radius: 16.0f32 },
            active: true,
            entity_type: EntityType.Player,
        })

        return Ok(GameState {
            entities: entities,
            player: Some(player_handle),
            score: 0,
            game_over: false,
        })
    }

    func spawn_enemy(self, x: f32, y: f32) -> Handle<Entity> or Error {
        return self.entities.insert(Entity {
            position: Position { x: x, y: y },
            velocity: Velocity { dx: -50.0f32, dy: 0.0f32 },
            health: Health { current: 20, max: 20 },
            collider: Collider { radius: 12.0f32 },
            active: true,
            entity_type: EntityType.Enemy,
        })
    }

    func spawn_projectile(self, x: f32, y: f32, dx: f32, dy: f32) -> Handle<Entity> or Error {
        return self.entities.insert(Entity {
            position: Position { x: x, y: y },
            velocity: Velocity { dx: dx, dy: dy },
            health: Health { current: 1, max: 1 },
            collider: Collider { radius: 4.0f32 },
            active: true,
            entity_type: EntityType.Projectile,
        })
    }
}

// System: Update positions based on velocities
// here we only use the entities pool from GameState, so we can use a projection
// This allows us to avoid borrowing the entire GameState
func movement_system(entities: GameState.{entities}, dt: f32) {
    for h in entities {
        if !entities[h].active: continue

        entities[h].position.x += entities[h].velocity.dx * dt
        entities[h].position.y += entities[h].velocity.dy * dt
    }
}

// System: Check collisions between entities
func collision_system(state: GameState) {
    let to_check = state.entities.handles()

    for i in 0..to_check.len() {
        for j in (i + 1)..to_check.len() {
            const h1 = to_check[i]
            const h2 = to_check[j]

            if !state.entities[h1].active || !state.entities[h2].active: continue

            const e1 = state.entities[h1]
            const e2 = state.entities[h2]

            // Calculate distance
            const dx = e1.position.x - e2.position.x
            const dy = e1.position.y - e2.position.y
            const dist = (dx * dx + dy * dy).sqrt()
            const min_dist = e1.collider.radius + e2.collider.radius

            if dist < min_dist {
                handle_collision(state, h1, h2)
            }
        }
    }
}

func handle_collision(state: GameState, h1: Handle<Entity>, h2: Handle<Entity>) {
    const type1 = state.entities[h1].entity_type
    const type2 = state.entities[h2].entity_type

    // Player vs Enemy
    if (type1 == EntityType.Player && type2 == EntityType.Enemy) ||
       (type1 == EntityType.Enemy && type2 == EntityType.Player) {
        const player_h = if type1 == EntityType.Player: h1 else: h2
        const enemy_h = if type1 == EntityType.Enemy: h1 else: h2

        state.entities[player_h].health.current -= 10
        state.entities[enemy_h].active = false

        if state.entities[player_h].health.current <= 0 {
            state.game_over = true
        }
    }

    // Projectile vs Enemy
    if (type1 == EntityType.Projectile && type2 == EntityType.Enemy) ||
       (type1 == EntityType.Enemy && type2 == EntityType.Projectile) {
        const enemy_h = if type1 == EntityType.Enemy: h1 else: h2
        const proj_h = if type1 == EntityType.Projectile: h1 else: h2

        state.entities[enemy_h].health.current -= 25
        state.entities[proj_h].active = false

        if state.entities[enemy_h].health.current <= 0 {
            state.entities[enemy_h].active = false
            state.score += 100
        }
    }
}

// System: Remove inactive entities
func cleanup_system(state: GameState) {
    let to_remove = Vec.new()

    for h in state.entities {
        if !state.entities[h].active {
            to_remove.push(h).ok()
        }
    }

    for h in to_remove {
        state.entities.remove(h)
    }
}

// System: Spawn enemies periodically
func spawn_system(state: GameState, time_since_last_spawn: f32) -> f32 {
    const spawn_interval = 2.0f32

    if time_since_last_spawn >= spawn_interval {
        // Spawn enemy at right edge with random y
        const y = (random.f32() * 500.0f32) + 50.0f32
        state.spawn_enemy(850.0f32, y).ok()
        return 0.0f32  // Reset timer
    } else {
        return time_since_last_spawn
    }
}

// Parallel movement update - processes entity batches across threads
func parallel_movement_system(entities: GameState.{entities}, dt: f32, num_threads: usize)
    with ThreadPool
{
    let handles = entities.handles()
    let chunk_size = (handles.len() + num_threads - 1) / num_threads

    // Split work across thread pool
    let thread_handles = Vec.new()
    for chunk in handles.chunks(chunk_size) {
        let chunk = chunk.to_vec()
        let task = spawn thread {
            for h in chunk {
                if !entities[h].active: continue
                entities[h].position.x += entities[h].velocity.dx * dt
                entities[h].position.y += entities[h].velocity.dy * dt
            }
        }
        thread_handles.push(task).ok()
    }

    // Wait for all chunks to complete
    for h in thread_handles {
        h.join().ok()
    }
}

// Main game loop with fixed timestep and threading
func main() -> () or Error {
    let state = try GameState.new()

    const target_fps = 60.0f32
    const dt = 1.0f32 / target_fps
    const NUM_PHYSICS_THREADS: usize = 4u64

    let last_time = 0.0f32  // Simplified: track elapsed time
    let accumulator = 0.0f32
    let spawn_timer = 0.0f32
    let frame_count = 0

    println("Game started! Score: 0")

    // Thread pool for CPU-bound physics work
    with ThreadPool(workers: 4) {
        // Simulate game for a few seconds
        while !state.game_over && frame_count < 300 {
        // Simulate frame time (16ms = ~60fps)
        const frame_time = 0.016f32
        last_time += frame_time

        accumulator += frame_time

        // Fixed timestep updates
        while accumulator >= dt {
            // Handle input (simulated - would be real input in actual game)
            if frame_count % 30 == 0 {
                // Fire projectile
                if state.player is Some(player_h) {
                    const px = state.entities[player_h].position.x
                    const py = state.entities[player_h].position.y
                    try state.spawn_projectile(px + 20.0f32, py, 300.0f32, 0.0f32)
                }
            }

            // Parallel physics: split entity updates across thread pool
            // Each thread processes a batch of entities
            parallel_movement_system(state, dt, NUM_PHYSICS_THREADS)

            // Collision runs single-threaded (needs to see all entities)
            collision_system(state)

            // Game logic on main thread
            spawn_timer = spawn_system(state, spawn_timer + dt)
            cleanup_system(state)

            accumulator -= dt
        }

        // Render (simulated - just print status occasionally)
        if frame_count % 60 == 0 {
            const entity_count = state.entities.len()
            let player_health = 0
            if state.player is Some(h) {
                player_health = state.entities[h].health.current
            }
            println("Frame {frame_count}: Entities={entity_count}, Health={player_health}, Score={state.score}")
        }

            frame_count += 1

            // In a real game, we'd sleep here to maintain frame rate
            // time.sleep(time.Duration.from_millis(16))
        }
    }

    if state.game_over {
        println("Game Over! Final Score: {state.score}")
    } else {
        println("Demo complete! Final Score: {state.score}")
    }

    return Result.Ok(())
}
