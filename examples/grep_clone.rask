// grep clone - Pattern Search CLI Tool
// Demonstrates: CLI args, file I/O, string operations, iteration, error handling

import fs
import cli
import std

struct Options {
    pattern: string
    files: Vec<string>
    ignore_case: bool
    line_numbers: bool
    count_only: bool
    invert_match: bool
}

enum GrepError {
    NoPattern,
    NoFiles,
    FileError(string),
}

extend GrepError {
    func message(self) -> string {
        match self {
            NoPattern => return "missing pattern argument",
            NoFiles => return "no files specified",
            FileError(msg) => return "{msg}",
        }
    }
}

func parse_args(args: Vec<string>) -> Options or GrepError {
    let opts = Options {
        pattern: "",
        files: Vec.new(),
        ignore_case: false,
        line_numbers: false,
        count_only: false,
        invert_match: false,
    }

    let positional = Vec.new()

    for arg in args.iter().skip(1) {
        match arg {
            "-i" => opts.ignore_case = true,
            "-n" => opts.line_numbers = true,
            "-c" => opts.count_only = true,
            "-v" => opts.invert_match = true,
            "-h" | "--help" => {
                print_usage()
                std.exit(0)
            }
            _ => positional.push(arg.clone()),
        }
    }

    if positional.len() == 0: return Err(GrepError.NoPattern)
    opts.pattern = positional[0].clone()

    // Collect remaining positional args as files
    if positional.len() == 1: return Err(GrepError.NoFiles)
    let i = 1
    while i < positional.len() {
        opts.files.push(positional[i].clone())
        i = i + 1
    }

    return Ok(opts)
}

func print_usage() {
    println("Usage: rgrep [OPTIONS] PATTERN FILE...")
    println("")
    println("Options:")
    println("  -i    Ignore case")
    println("  -n    Show line numbers")
    println("  -c    Count matching lines only")
    println("  -v    Invert match (show non-matching lines)")
    println("  -h    Show this help")
}

func line_matches(line: string, pattern: string, ignore_case: bool) -> bool {
    if ignore_case {
        const lower_line = line.to_lowercase()
        const lower_pattern = pattern.to_lowercase()
        return lower_line.contains(lower_pattern)
    } else {
        return line.contains(pattern)
    }
}

func grep_file(path: string, opts: Options) -> i64 or GrepError {
    const content = try fs.read_file(path.clone())
        .map_err(|e| GrepError.FileError(e))

    const lines = content.lines()
    let match_count: i64 = 0
    let line_num = 0

    for line in lines {
        line_num = line_num + 1
        const matches = line_matches(line.clone(), opts.pattern.clone(), opts.ignore_case)
        const show = if opts.invert_match: !matches else: matches

        if show {
            match_count = match_count + 1

            if !opts.count_only {
                if opts.line_numbers {
                    println("{line_num}:{line}")
                } else {
                    println("{line}")
                }
            }
        }
    }

    if opts.count_only {
        println("{match_count}")
    }

    return Ok(match_count)
}

@entry
func main() {
    const args = cli.args()
    const opts = match parse_args(args) {
        Ok(o) => o,
        Err(e) => {
            const msg = e.message()
            println("rgrep: {msg}")
            print_usage()
            std.exit(1)
        }
    }

    let total_matches = 0
    let had_errors = false

    for file_path in opts.files.clone() {
        match grep_file(file_path, opts.clone()) {
            Ok(count) => total_matches = total_matches + count,
            Err(e) => {
                const msg = e.message()
                println("rgrep: {msg}")
                had_errors = true
            }
        }
    }

    if had_errors: std.exit(2)
    if total_matches == 0: std.exit(1)
}
