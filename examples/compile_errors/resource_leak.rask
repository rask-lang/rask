// SPDX-License-Identifier: (MIT OR Apache-2.0)
// Compile Error: Resource type not consumed
// ERROR: resource 'file' must be consumed before scope ends

// This file demonstrates that @resource types must be consumed exactly once.
// You cannot forget to close a file or drop a connection.

import fs

func process_data() -> () or Error {
    // Open a file - this returns a @resource type
    const file = try fs.open("data.txt")

    // Read some data
    const data = try file.read_all()

    // Process data...
    process(data)

    // COMPILE ERROR: 'file' is a resource that must be consumed
    // We forgot to close it!

    Ok(())
}

// Why this is an error:
// @resource types have linear semantics - they must be used exactly once.
// This ensures:
// - Files are always closed
// - Connections are always terminated
// - Locks are always released
// - Transactions are always committed or rolled back

// THE FIX: Consume the resource

// Option 1: Explicit close
func process_data_v1() -> () or Error {
    const file = try fs.open("data.txt")
    const data = try file.read_all()
    process(data)
    try file.close()  // Consumes the resource
    Ok(())
}

// Option 2: Use 'ensure' for automatic cleanup
func process_data_v2() -> () or Error {
    const file = try fs.open("data.txt")
    ensure file.close()  // Runs at scope exit, even on early return

    const data = try file.read_all()
    process(data)

    if data.is_empty() {
        return Err(Error.new("empty file"))  // ensure still runs!
    }

    Ok(())
}

// Option 3: Scoped resource pattern
func process_data_v3() -> () or Error {
    (try fs.open("data.txt")).use(|file| {
        const data = try file.read_all()
        process(data)
        Ok(())
    })
}

// Another error case: resource in a branch that doesn't consume
func conditional_leak(flag: bool) -> () or Error {
    const file = try fs.open("data.txt")

    if flag {
        try file.close()
    }
    // COMPILE ERROR: 'file' may not be consumed (false branch doesn't close)

    Ok(())
}

// THE FIX: All branches must consume
func conditional_fixed(flag: bool) -> () or Error {
    const file = try fs.open("data.txt")

    if flag {
        const data = try file.read_all()
        process(data)
        try file.close()
    } else {
        try file.close()  // Must close in both branches
    }

    Ok(())
}

func process(data: string) {
    // ...
}


@entry
func main() -> () or Error {

    try process_data()
    try process_data_v1()
    try process_data_v2()
    Ok(())
}