// Solution: Lesson 19

struct Vec3 {
    x: f64
    y: f64
    z: f64
}

extend Vec3 {
    func zero() -> Vec3 { return Vec3 { x: 0.0, y: 0.0, z: 0.0 } }
    func new(x: f64, y: f64, z: f64) -> Vec3 { return Vec3 { x: x, y: y, z: z } }

    func add(self, other: Vec3) -> Vec3 {
        return Vec3 { x: self.x + other.x, y: self.y + other.y, z: self.z + other.z }
    }
    func scale(self, s: f64) -> Vec3 {
        return Vec3 { x: self.x * s, y: self.y * s, z: self.z * s }
    }
    func magnitude(self) -> f64 {
        const sq = self.x * self.x + self.y * self.y + self.z * self.z
        return sqrt(sq)
    }
}

func sqrt(x: f64) -> f64 {
    if x <= 0.0 { return 0.0 }
    let g = x / 2.0
    for i in 0..30 { g = (g + x / g) / 2.0 }
    return g
}

struct Aircraft {
    position: Vec3
    velocity: Vec3
    mass: f64
    thrust_n: f64
    wing_area: f64
    drag_coeff: f64
    lift_coeff: f64
}

enum Phase {
    Ground
    Takeoff
    Climbing
    Cruising
    Descending
    Landed
}

func gravity(ac: Aircraft) -> Vec3 {
    return Vec3 { x: 0.0, y: 0.0, z: -ac.mass * 9.81 }
}

func thrust(ac: Aircraft) -> Vec3 {
    return Vec3 { x: 0.0, y: ac.thrust_n, z: 0.0 }
}

func drag(ac: Aircraft) -> Vec3 {
    const speed = ac.velocity.magnitude()
    if speed == 0.0 { return Vec3.zero() }
    const rho = 1.225
    const mag = 0.5 * rho * speed * speed * ac.drag_coeff * ac.wing_area
    return ac.velocity.scale(-mag / speed)
}

func lift(ac: Aircraft) -> Vec3 {
    const speed = ac.velocity.magnitude()
    const rho = 1.225
    const mag = 0.5 * rho * speed * speed * ac.lift_coeff * ac.wing_area
    return Vec3 { x: 0.0, y: 0.0, z: mag }
}

func total_force(ac: Aircraft) -> Vec3 {
    return gravity(ac).add(thrust(ac)).add(drag(ac)).add(lift(ac))
}

func step(ac: Aircraft, dt: f64) -> Aircraft {
    const f = total_force(ac)
    const accel = f.scale(1.0 / ac.mass)
    const new_vel = ac.velocity.add(accel.scale(dt))
    let new_pos = ac.position.add(new_vel.scale(dt))
    if new_pos.z < 0.0 {
        new_pos = Vec3 { x: new_pos.x, y: new_pos.y, z: 0.0 }
    }
    return Aircraft {
        position: new_pos,
        velocity: new_vel,
        mass: ac.mass,
        thrust_n: ac.thrust_n,
        wing_area: ac.wing_area,
        drag_coeff: ac.drag_coeff,
        lift_coeff: ac.lift_coeff,
    }
}

func determine_phase(ac: Aircraft) -> Phase {
    const altitude = ac.position.z
    const speed = ac.velocity.magnitude()
    const vz = ac.velocity.z

    if altitude <= 0.0 && speed < 1.0 { return Phase.Ground }
    if altitude <= 0.0 && speed >= 1.0 { return Phase.Takeoff }
    if altitude > 0.0 && vz > 1.0 { return Phase.Climbing }
    if altitude > 0.0 && vz < -1.0 { return Phase.Descending }
    return Phase.Cruising
}

func phase_name(p: Phase) -> string {
    return match p {
        Ground => "ground",
        Takeoff => "takeoff",
        Climbing => "climbing",
        Cruising => "cruising",
        Descending => "descending",
        Landed => "landed",
    }
}

func simulate(ac: Aircraft, dt: f64, n_steps: i32) -> f64 {
    let current = ac
    for i in 0..n_steps {
        current = step(current, dt)
    }
    return current.position.z
}

test "gravity force" {
    const ac = Aircraft {
        position: Vec3.zero(), velocity: Vec3.zero(),
        mass: 1000.0, thrust_n: 0.0, wing_area: 20.0,
        drag_coeff: 0.03, lift_coeff: 0.5,
    }
    const g = gravity(ac)
    assert g.x == 0.0
    assert g.y == 0.0
    assert g.z < -9800.0
    assert g.z > -9820.0
}

test "thrust force" {
    const ac = Aircraft {
        position: Vec3.zero(), velocity: Vec3.zero(),
        mass: 1000.0, thrust_n: 50000.0, wing_area: 20.0,
        drag_coeff: 0.03, lift_coeff: 0.5,
    }
    const t = thrust(ac)
    assert t.x == 0.0
    assert t.y == 50000.0
    assert t.z == 0.0
}

test "drag at rest is zero" {
    const ac = Aircraft {
        position: Vec3.zero(), velocity: Vec3.zero(),
        mass: 1000.0, thrust_n: 0.0, wing_area: 20.0,
        drag_coeff: 0.03, lift_coeff: 0.5,
    }
    const d = drag(ac)
    assert d.x == 0.0
    assert d.y == 0.0
    assert d.z == 0.0
}

test "drag opposes velocity" {
    const ac = Aircraft {
        position: Vec3.zero(),
        velocity: Vec3.new(0.0, 100.0, 0.0),
        mass: 1000.0, thrust_n: 0.0, wing_area: 20.0,
        drag_coeff: 0.03, lift_coeff: 0.5,
    }
    const d = drag(ac)
    assert d.y < 0.0
}

test "total force" {
    const ac = Aircraft {
        position: Vec3.zero(),
        velocity: Vec3.new(0.0, 50.0, 0.0),
        mass: 1000.0, thrust_n: 20000.0, wing_area: 20.0,
        drag_coeff: 0.03, lift_coeff: 0.5,
    }
    const f = total_force(ac)
    assert f.y > 0.0
}

test "euler step" {
    const ac = Aircraft {
        position: Vec3.zero(),
        velocity: Vec3.new(0.0, 100.0, 10.0),
        mass: 1000.0, thrust_n: 20000.0, wing_area: 20.0,
        drag_coeff: 0.03, lift_coeff: 0.5,
    }
    const next = step(ac, 0.1)
    assert next.position.y > 0.0
    assert next.position.z > 0.0
}

test "flight phase" {
    const grounded = Aircraft {
        position: Vec3.zero(), velocity: Vec3.zero(),
        mass: 1000.0, thrust_n: 0.0, wing_area: 20.0,
        drag_coeff: 0.03, lift_coeff: 0.5,
    }
    assert phase_name(determine_phase(grounded)) == "ground"

    const climbing = Aircraft {
        position: Vec3.new(0.0, 0.0, 1000.0),
        velocity: Vec3.new(0.0, 100.0, 5.0),
        mass: 1000.0, thrust_n: 20000.0, wing_area: 20.0,
        drag_coeff: 0.03, lift_coeff: 0.5,
    }
    assert phase_name(determine_phase(climbing)) == "climbing"
}

test "simulation runs" {
    const ac = Aircraft {
        position: Vec3.zero(),
        velocity: Vec3.new(0.0, 50.0, 0.0),
        mass: 1000.0, thrust_n: 30000.0, wing_area: 20.0,
        drag_coeff: 0.03, lift_coeff: 1.2,
    }
    const final_alt = simulate(ac, 0.1, 100)
    assert final_alt > 0.0
}

func main() {
    let ac = Aircraft {
        position: Vec3.zero(),
        velocity: Vec3.new(0.0, 70.0, 0.0),
        mass: 2000.0,
        thrust_n: 25000.0,
        wing_area: 16.0,
        drag_coeff: 0.03,
        lift_coeff: 1.0,
    }

    println("=== Flight Simulation ===")
    for t in 0..50 {
        const phase = phase_name(determine_phase(ac))
        const alt = ac.position.z
        const speed = ac.velocity.magnitude()
        if t % 10 == 0 {
            println("t={t}s  alt={alt}m  speed={speed}m/s  phase={phase}")
        }
        ac = step(ac, 0.2)
    }
    println("Final altitude: {ac.position.z}m")
}
