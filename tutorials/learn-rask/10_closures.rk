// === Lesson 10: Closures and Higher-Order Functions ===
//
// In Python:   square = lambda x: x * x
//              list(map(square, [1, 2, 3]))  → [1, 4, 9]
//
// In Rask:     const square = |x| x * x
//              vec.map(|x| x * x)
//
// Closures are anonymous functions — functions without a name.
// The syntax: |parameters| body
//
//   |x| x * 2                       // one parameter, one expression
//   |x, y| { return x + y }         // multiple params, braces for multi-line
//   || println("no params")          // no parameters
//
// Closures can use variables from the surrounding code:
//   const factor = 3
//   const scaled = numbers.map(|n| n * factor)    // "factor" is used inside
//
// Vec methods that take closures (these replace Python's map/filter/reduce):
//   .map(|item| ...)        — transform each element
//   .filter(|item| ...)     — keep elements where closure returns true
//   .any(|item| ...)        — true if any element matches
//   .all(|item| ...)        — true if all match
//   .fold(init, |acc, item| ...)  — reduce to single value (Python's functools.reduce)
//

// --- Example ---

func example_closures() {
    const numbers = Vec.from([1, 2, 3, 4, 5])

    const doubled = numbers.map(|n| n * 2)
    println("doubled: {doubled}")

    const evens = numbers.filter(|n| n % 2 == 0)
    println("evens: {evens}")

    const sum = numbers.fold(0, |acc, n| acc + n)
    println("sum: {sum}")

    // Chain operations — like piping in Python
    const result = numbers
        .filter(|n| n > 2)
        .map(|n| n * n)
    println("squares of >2: {result}")
}

// ============================================================
// PUZZLES
// ============================================================

// --- Puzzle 1: Numerical integration (trapezoid rule) ---
// Approximate the area under a curve using trapezoids.
//
// The function f is passed as a closure — your first higher-order function.
//
// Formula: divide [a, b] into n equal strips of width h = (b-a)/n
//   area ≈ h × (f(a)/2 + f(a+h) + f(a+2h) + ... + f(b)/2)
//
// Fun fact: this is how many physics simulations compute energy.
// When you integrate force over distance, you get work done.
// When you integrate acceleration over time, you get velocity.
func integrate(f: |f64| -> f64, a: f64, b: f64, n: i32) -> f64 {
    panic("TODO")
}

// --- Puzzle 2: Autopilot altitude filter ---
// An autopilot receives altitude readings in feet from multiple sensors.
// Process the readings:
//   1. Convert feet to meters (1 foot = 0.3048 meters)
//   2. Keep only readings at or above cruising altitude (10,000 meters)
//
// Fun fact: 10,000 meters (32,808 ft) is roughly where the tropopause
// begins — the boundary between the troposphere and stratosphere.
// Above this, temperature stops decreasing with altitude.
func cruising_altitudes_meters(readings_feet: Vec<f64>) -> Vec<f64> {
    panic("TODO")
}

// --- Puzzle 3: Apply function n times ---
// apply_n(f, x, 3) = f(f(f(x)))
//
// This is function composition — a fundamental concept in math.
// It's also how iterative methods work: apply the same transformation
// repeatedly until you converge on an answer. Newton's method (lesson 03)
// was exactly this: applying the update rule over and over.
func apply_n(f: |f64| -> f64, x: f64, n: i32) -> f64 {
    panic("TODO")
}

// --- Puzzle 4: Numerical derivative ---
// Approximate f'(x) using the central difference method:
//   f'(x) ≈ (f(x + h) - f(x - h)) / (2h)
//
// Use h = 1e-7. This gives about 7 digits of accuracy.
//
// Fun fact: this is how autodiff works at its simplest level.
// Modern ML frameworks (PyTorch, JAX) use more sophisticated
// versions of the same idea.
func derivative(f: |f64| -> f64, x: f64) -> f64 {
    panic("TODO")
}

// --- Tests ---

test "integrate x squared from 0 to 1" {
    // ∫₀¹ x² dx = 1/3 ≈ 0.3333
    const result = integrate(|x| x * x, 0.0, 1.0, 10000)
    assert result > 0.333
    assert result < 0.334
}

test "integrate approximate sin" {
    // Using x - x³/6 as rough sin(x)
    // ∫₀^π sin(x) dx ≈ 2.0
    const result = integrate(|x| x - x * x * x / 6.0, 0.0, 3.14159, 10000)
    assert result > 1.9
    assert result < 2.1
}

test "cruising altitudes" {
    const readings = Vec.from([35000.0, 28000.0, 15000.0, 41000.0, 5000.0])
    const cruising = cruising_altitudes_meters(readings)
    // 35000 ft = 10668 m ✓, 28000 ft = 8534 m ✗, 41000 ft = 12496 m ✓
    assert cruising.len() == 2
    assert cruising[0] > 10600.0
    assert cruising[1] > 12400.0
}

test "apply n times" {
    // Double 3 times: 1 → 2 → 4 → 8
    assert apply_n(|x| x * 2.0, 1.0, 3) == 8.0
    assert apply_n(|x| x + 1.0, 0.0, 5) == 5.0
}

test "derivative of x squared at x=3" {
    // d/dx(x²) = 2x → at x=3: 6.0
    const d = derivative(|x| x * x, 3.0)
    assert d > 5.99
    assert d < 6.01
}

test "derivative of x cubed at x=2" {
    // d/dx(x³) = 3x² → at x=2: 12.0
    const d = derivative(|x| x * x * x, 2.0)
    assert d > 11.99
    assert d < 12.01
}

func main() {
    example_closures()
    println("Run 'rask test 10_closures.rk' to check your puzzles")
}
