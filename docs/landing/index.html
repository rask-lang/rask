<!-- SPDX-License-Identifier: (MIT OR Apache-2.0) -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rask - Memory safety without lifetime annotations</title>
    <meta name="description" content="A systems programming language with memory safety and no garbage collection. Compile-time safety without the complexity.">
    <link rel="icon" type="image/png" href="../book/src/assets/rask32.png">
    <link rel="stylesheet" href="landing.css">
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <div class="nav-links">
                <a href="book/index.html">docs</a>
                <a href="blog/">blog</a>
                <a href="app/">playground</a>
                <a href="https://github.com/rask-lang/rask">github ↗</a>
            </div>
            <div class="status">design phase · working interpreter</div>
        </div>
    </nav>

    <main class="container">
        <section class="hero">
            <img src="book/assets/rask-logo-white@3x.png" alt="Rask" class="hero-logo">
            <p class="tagline">The Rust-Go dilemma, solved.</p>
            <p class="subtitle">
                Simpler than Rust, safer than Go.<br>
                No lifetime annotations, no garbage collection.
            </p>
            <div class="cta">
                <a href="app/" class="btn primary">→ try in browser</a>
                <a href="book/index.html" class="btn secondary">read docs</a>
            </div>
        </section>

        <section class="insight">
            <h2>The breakthrough</h2>
            <p>Rust's complexity comes from allowing references to be stored in structs and returned from functions. Tracking those references requires lifetime annotations that spread through your entire codebase.</p>

            <p><strong>Rask's approach:</strong> Make references temporary—they exist only within a block or expression. When you need longer-lived relationships, use handles (opaque identifiers) instead.</p>

            <div class="tradeoff-box">
                <div class="cost">
                    <h3>The cost</h3>
                    <p>Explicit indirection for graphs. Some .clone() calls for shared data.</p>
                </div>
                <div class="benefit">
                    <h3>The benefit</h3>
                    <p>No lifetime annotations. No borrow checker fights. Simple mental model.</p>
                </div>
            </div>
        </section>

        <section class="mechanisms">
            <h2>How it works</h2>

            <div class="mechanism">
                <h3>Block-scoped borrowing</h3>
                <p>References can't be stored or returned. They're temporary views, valid only within their block. This eliminates lifetime tracking.</p>
                <div class="window">
                    <div class="title-bar">
                        <div class="dots"><span></span><span></span><span></span></div>
                        <span class="filename">borrowing.rk</span>
                    </div>
                    <pre><code><span class="cmt">// References are temporary</span>
<span class="kw">func</span> <span class="fn">process</span>(data: Data) {
    <span class="kw">const</span> name = data.user.name  <span class="cmt">// temporary borrow</span>
    <span class="cmt">// name is gone at end of block</span>
}</code></pre>
                </div>
            </div>

            <div class="mechanism">
                <h3>Handles for relationships</h3>
                <p>For graphs and long-lived relationships, use Pool&lt;T&gt; + Handle&lt;T&gt;. Handles are checked at runtime—no lifetimes needed.</p>
                <div class="window">
                    <div class="title-bar">
                        <div class="dots"><span></span><span></span><span></span></div>
                        <span class="filename">handles.rk</span>
                    </div>
                    <pre><code><span class="cmt">// Graphs without lifetimes</span>
<span class="kw">struct</span> <span class="ty">Entity</span> {
    target: <span class="ty">Handle</span>&lt;<span class="ty">Entity</span>&gt;?
}
<span class="kw">const</span> entities = <span class="ty">Pool</span>&lt;<span class="ty">Entity</span>&gt;.<span class="fn">new</span>()
entities[enemy].target = player_handle</code></pre>
                </div>
            </div>

            <div class="mechanism">
                <h3>Resource types</h3>
                <p>Files and system resources must be explicitly consumed. The compiler enforces cleanup on all exit paths.</p>
                <div class="window">
                    <div class="title-bar">
                        <div class="dots"><span></span><span></span><span></span></div>
                        <span class="filename">resources.rk</span>
                    </div>
                    <pre><code><span class="kw">func</span> <span class="fn">backup</span>(src: <span class="ty">string</span>, dst: <span class="ty">string</span>) -> () <span class="kw">or</span> <span class="ty">Error</span> {
    <span class="kw">const</span> file = <span class="kw">try</span> fs.<span class="fn">open</span>(src)
    <span class="kw">ensure</span> file.<span class="fn">close</span>()  <span class="cmt">// runs on all exits</span>
    <span class="kw">try</span> <span class="fn">write</span>(file)
}</code></pre>
                </div>
            </div>

            <div class="mechanism">
                <h3>No function coloring</h3>
                <p>I/O operations pause green tasks automatically. No async/await splitting your ecosystem.</p>
                <div class="window">
                    <div class="title-bar">
                        <div class="dots"><span></span><span></span><span></span></div>
                        <span class="filename">concurrency.rk</span>
                    </div>
                    <pre><code><span class="kw">func</span> <span class="fn">fetch_user</span>(id: <span class="ty">u64</span>) -> <span class="ty">User</span> <span class="kw">or</span> <span class="ty">Error</span> {
    <span class="kw">const</span> resp = <span class="kw">try</span> <span class="fn">http_get</span>(url)  <span class="cmt">// pauses task</span>
    <span class="kw">return</span> <span class="fn">parse</span>(resp)
}</code></pre>
                </div>
            </div>
        </section>

        <section class="tradeoffs">
            <h2>The tradeoffs</h2>
            <p>Every design makes tradeoffs. Rask's are intentional:</p>

            <table>
                <tr>
                    <th>You give up</th>
                    <th>You get</th>
                </tr>
                <tr>
                    <td>Storable references</td>
                    <td>No lifetime annotations</td>
                </tr>
                <tr>
                    <td>Implicit string sharing</td>
                    <td>Explicit .clone() when needed</td>
                </tr>
                <tr>
                    <td>Direct pointer traversal</td>
                    <td>Handles with runtime checks</td>
                </tr>
            </table>

            <p>If you need nanosecond-precise control or pointer-level optimization, use Rust or C++. Rask targets the 80% of systems code where safety and productivity matter more than squeezing out the last 5% of performance.</p>
        </section>

        <section class="result">
            <h2>What you get</h2>
            <ul>
                <li>Memory safety without lifetime annotations</li>
                <li>No garbage collection, deterministic cleanup</li>
                <li>Predictable performance (no GC pauses)</li>
                <li>Fast compilation (local analysis only)</li>
                <li>Simple mental model (values are owned, borrows are temporary)</li>
            </ul>
        </section>

        <section class="philosophy">
            <h2>The goal</h2>
            <p>Rask targets the 80% of systems code where safety and productivity matter more than squeezing out the last 5% of performance. You get memory safety without fighting the borrow checker.</p>

            <p>You still manage ownership and resources—through block scopes and explicit keywords, not lifetime annotations. Major costs (allocations, locks, I/O) stay visible. Small safety checks (bounds, nulls) are implicit.</p>

            <p>Rask draws from everywhere: Rust's ownership, Zig's comptime, Erlang's supervision, Vale's regions. The goal is Rust's safety with Go's approachability.</p>
        </section>

        <section class="status-section">
            <h2>Where we are</h2>

            <p class="status">Rask is in early development (pre-0.1). The design is coherent and there's a working interpreter, but expect breaking changes and bugs as the language evolves.</p>
            <p class="contribute">The language is open for new ideas and constructive feedback. Contributions are welcome on <a href="https://github.com/rask-lang/rask/issues">GitHub issues</a>.</p>
        </section>
    </main>

    <footer>
        <div class="container">
            <a href="book/index.html">docs</a> ·
            <a href="../playground/">playground</a> ·
            <a href="https://github.com/rask-lang/rask">github</a> ·
            <a href="https://github.com/rask-lang/rask/blob/main/LICENSE-MIT">mit/apache-2.0</a>
        </div>
    </footer>

</body>
</html>
