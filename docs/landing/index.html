<!-- SPDX-License-Identifier: (MIT OR Apache-2.0) -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rask - A research language exploring no-storable-references</title>
    <meta name="description" content="A research programming language exploring memory safety without storable references, lifetime annotations, or garbage collection.">
    <link rel="icon" type="image/png" href="/book/assets/rask32.png">
    <link rel="stylesheet" href="landing.css">
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <div class="nav-links">
                <a href="book/index.html">docs</a>
                <a href="blog/">blog</a>
                <a href="app/">playground</a>
                <a href="https://github.com/rask-lang/rask">github ↗</a>
            </div>
            <div class="status">design phase · working interpreter</div>
        </div>
    </nav>

    <main class="container">
        <section class="hero">
            <img src="book/assets/rask-logo-white@3x.png" alt="Rask" class="hero-logo">
            <p class="tagline">What if references can't be stored?</p>
            <p class="subtitle">
                A research language exploring memory safety<br>
                without lifetime annotations or garbage collection.
            </p>
            <div class="cta">
                <a href="app/" class="btn primary">try in browser</a>
                <a href="book/index.html" class="btn secondary">read docs</a>
            </div>
        </section>

        <section class="insight">
            <h2>The idea</h2>
            <p>Most of Rust's complexity comes from allowing references to be stored in structs and returned from functions. Tracking those references requires lifetime annotations that spread through your codebase.</p>

            <p><strong>Rask's experiment:</strong> What if references are always temporary — they exist only within a block or expression? When you need longer-lived relationships, use handles (opaque identifiers) instead.</p>

            <div class="tradeoff-box">
                <div class="cost">
                    <h3>The cost</h3>
                    <p>Explicit indirection for graphs. Some .clone() calls for shared data.</p>
                </div>
                <div class="benefit">
                    <h3>The benefit</h3>
                    <p>No lifetime annotations. No borrow checker fights. Simple mental model.</p>
                </div>
            </div>
        </section>

        <section class="mechanisms">
            <h2>How it works</h2>

            <div class="mechanism">
                <h3>Block-scoped borrowing</h3>
                <p>References can't be stored or returned. They're temporary views, valid only within their block. This eliminates lifetime tracking.</p>
                <div class="window">
                    <div class="title-bar">
                        <div class="dots"><span></span><span></span><span></span></div>
                        <span class="filename">borrowing.rk</span>
                    </div>
                    <pre><code><span class="cmt">// References are temporary</span>
<span class="kw">func</span> <span class="fn">process</span>(data: Data) {
    <span class="kw">const</span> name = data.user.name  <span class="cmt">// temporary borrow</span>
    <span class="cmt">// name is gone at end of block</span>
}</code></pre>
                </div>
            </div>

            <div class="mechanism">
                <h3>Handles for relationships</h3>
                <p>For graphs and long-lived relationships, use Pool&lt;T&gt; + Handle&lt;T&gt;. Handles are checked at runtime—no lifetimes needed.</p>
                <div class="window">
                    <div class="title-bar">
                        <div class="dots"><span></span><span></span><span></span></div>
                        <span class="filename">handles.rk</span>
                    </div>
                    <pre><code><span class="cmt">// Graphs without lifetimes</span>
<span class="kw">struct</span> <span class="ty">Entity</span> {
    target: <span class="ty">Handle</span>&lt;<span class="ty">Entity</span>&gt;?
}
<span class="kw">const</span> entities = <span class="ty">Pool</span>&lt;<span class="ty">Entity</span>&gt;.<span class="fn">new</span>()
entities[enemy].target = player_handle</code></pre>
                </div>
            </div>

            <div class="mechanism">
                <h3>Resource types</h3>
                <p>Files and system resources must be explicitly consumed. The compiler enforces cleanup on all exit paths.</p>
                <div class="window">
                    <div class="title-bar">
                        <div class="dots"><span></span><span></span><span></span></div>
                        <span class="filename">resources.rk</span>
                    </div>
                    <pre><code><span class="kw">func</span> <span class="fn">backup</span>(src: <span class="ty">string</span>, dst: <span class="ty">string</span>) -> () <span class="kw">or</span> <span class="ty">Error</span> {
    <span class="kw">const</span> file = <span class="kw">try</span> fs.<span class="fn">open</span>(src)
    <span class="kw">ensure</span> file.<span class="fn">close</span>()  <span class="cmt">// runs on all exits</span>
    <span class="kw">try</span> <span class="fn">write</span>(file)
}</code></pre>
                </div>
            </div>

            <div class="mechanism">
                <h3>No function coloring</h3>
                <p>I/O operations pause green tasks automatically. No async/await splitting your ecosystem.</p>
                <div class="window">
                    <div class="title-bar">
                        <div class="dots"><span></span><span></span><span></span></div>
                        <span class="filename">concurrency.rk</span>
                    </div>
                    <pre><code><span class="kw">func</span> <span class="fn">fetch_user</span>(id: <span class="ty">u64</span>) -> <span class="ty">User</span> <span class="kw">or</span> <span class="ty">Error</span> {
    <span class="kw">const</span> resp = <span class="kw">try</span> <span class="fn">http_get</span>(url)  <span class="cmt">// pauses task</span>
    <span class="kw">return</span> <span class="fn">parse</span>(resp)
}</code></pre>
                </div>
            </div>
        </section>

        <section class="tradeoffs">
            <h2>The tradeoffs</h2>
            <p>Here's what you give up and what you get:</p>

            <table>
                <tr>
                    <th>You give up</th>
                    <th>You get</th>
                </tr>
                <tr>
                    <td>Storable references</td>
                    <td>No lifetime annotations</td>
                </tr>
                <tr>
                    <td>Implicit string sharing</td>
                    <td>Explicit .clone() when needed</td>
                </tr>
                <tr>
                    <td>Direct pointer traversal</td>
                    <td>Handles with runtime checks</td>
                </tr>
            </table>

            <p>For pointer-level optimization, use Rust or C++. I'm betting that most application code can live with these tradeoffs — but that's still being tested.</p>
        </section>

        <section class="philosophy">
            <h2>What I'm going for</h2>
            <p>I'm exploring whether no-storable-references can cover the 80% of systems code that's really application code — servers, tools, games — with less friction than Rust. The language draws from Rust's ownership, Zig's comptime, Erlang's supervision, and Vale's generational references. Whether it all holds together is still an open question.</p>
        </section>

        <section class="status-section">
            <h2>Where we are</h2>

            <p class="status">Rask is in early development (pre-0.1). There's a working interpreter but no compiler yet. Expect breaking changes, bugs, and design pivots.</p>
            <p class="contribute">This is a hobby project, but feedback and ideas are welcome on <a href="https://github.com/rask-lang/rask/issues">GitHub issues</a>.</p>
        </section>
    </main>

    <footer>
        <div class="container">
            <a href="book/index.html">docs</a> ·
            <a href="app/">playground</a> ·
            <a href="https://github.com/rask-lang/rask">github</a> ·
            <a href="https://github.com/rask-lang/rask/blob/main/LICENSE-MIT">mit/apache-2.0</a>
        </div>
    </footer>

</body>
</html>
