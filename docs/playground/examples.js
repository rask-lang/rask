// SPDX-License-Identifier: (MIT OR Apache-2.0)
// Auto-generated from examples/*.rk files
// Run: node build-examples.js

export const EXAMPLES = {
    "01_variables": "// Learn: Variables and basic types\n\nfunc main() {\n    // const - binding won't be reassigned\n    const name = \"Alice\"\n    const age = 30\n    const height = 1.75\n\n    print(\"Name: \")\n    print(name)\n    print(\"\\n\")\n\n    print(\"Age: \")\n    print(age)\n    print(\"\\n\")\n\n    // let - binding can be reassigned\n    let counter = 0\n    counter = counter + 1\n    counter = counter + 1\n\n    print(\"Counter: \")\n    print(counter)\n    print(\"\\n\")\n}\n",
    "02_functions": "// Learn: Functions and return values\n\nfunc main() {\n    const result = add(5, 3)\n    print(\"5 + 3 = \")\n    print(result)\n    print(\"\\n\")\n\n    const doubled = double(7)\n    print(\"7 Ã— 2 = \")\n    print(doubled)\n    print(\"\\n\")\n\n    greet(\"World\")\n}\n\nfunc add(a: i32, b: i32) -> i32 {\n    return a + b\n}\n\nfunc double(x: i32) -> i32 {\n    return x * 2\n}\n\nfunc greet(name: string) {\n    print(\"Hello, \")\n    print(name)\n    print(\"!\\n\")\n}\n",
    "03_collections": "// Learn: Vec and Map collections\n\nfunc main() {\n    // Vec - ordered collection\n    const numbers = Vec.from([1, 2, 3, 4, 5])\n\n    print(\"Vec length: \")\n    print(numbers.len())\n    print(\"\\n\")\n\n    print(\"Numbers: \")\n    print(numbers.join(\", \"))\n    print(\"\\n\")\n\n    // Map - key-value pairs\n    const scores = Map.new()\n    try scores.insert(\"Alice\", 95)\n    try scores.insert(\"Bob\", 87)\n    try scores.insert(\"Charlie\", 92)\n\n    const alice_score = scores.get(\"Alice\")\n    if alice_score is Some(score) {\n        print(\"Alice's score: \")\n        print(score)\n        print(\"\\n\")\n    }\n\n    print(\"Total students: \")\n    print(scores.len())\n    print(\"\\n\")\n}\n",
    "04_pattern_matching": "// Learn: Pattern matching with match and if-is\n\nfunc main() {\n    // Match expression\n    const x = 2\n    const name = match x {\n        1 => \"one\",\n        2 => \"two\",\n        3 => \"three\",\n        _ => \"many\",\n    }\n\n    print(\"Number \")\n    print(x)\n    print(\" is \")\n    print(name)\n    print(\"\\n\")\n\n    // Pattern matching with Option\n    const maybe = Some(42)\n\n    if maybe is Some(value) {\n        print(\"Got value: \")\n        print(value)\n        print(\"\\n\")\n    }\n\n    const nothing = None\n\n    if nothing is None {\n        print(\"Got nothing\\n\")\n    }\n}\n",
    "05_loops": "// Learn: For loops and iteration\n\nfunc main() {\n    // Loop over range\n    print(\"Counting 1 to 5:\\n\")\n    for i in 1..6 {\n        print(i)\n        print(\" \")\n    }\n    print(\"\\n\\n\")\n\n    // Loop over Vec\n    const fruits = Vec.from([\"apple\", \"banana\", \"cherry\"])\n\n    print(\"Fruits:\\n\")\n    for fruit in fruits.iter() {\n        print(\"- \")\n        print(fruit)\n        print(\"\\n\")\n    }\n\n    // While loop\n    let count = 0\n    print(\"\\nWhile counting:\\n\")\n    while count < 3 {\n        print(count)\n        print(\" \")\n        count = count + 1\n    }\n    print(\"\\n\")\n}\n",
    "06_structs": "// Learn: Structs and methods\n\nstruct Person {\n    name: string\n    age: i32\n}\n\nextend Person {\n    func greet(self) {\n        print(\"Hello, I'm \")\n        print(self.name)\n        print(\" and I'm \")\n        print(self.age)\n        print(\" years old.\\n\")\n    }\n\n    func is_adult(self) -> bool {\n        return self.age >= 18\n    }\n}\n\nfunc main() {\n    const alice = Person {\n        name: \"Alice\",\n        age: 25,\n    }\n\n    alice.greet()\n\n    if alice.is_adult() {\n        print(\"Alice is an adult\\n\")\n    }\n\n    const bob = Person {\n        name: \"Bob\",\n        age: 16,\n    }\n\n    bob.greet()\n\n    if !bob.is_adult() {\n        print(\"Bob is not an adult yet\\n\")\n    }\n}\n",
    "07_error_handling": "// Learn: Error handling with Result and try\n\nfunc main() {\n    // Handling Result with match\n    const result = divide(10, 2)\n\n    match result {\n        Ok(value) => {\n            print(\"10 / 2 = \")\n            print(value)\n            print(\"\\n\")\n        }\n        Err(msg) => {\n            print(\"Error: \")\n            print(msg)\n            print(\"\\n\")\n        }\n    }\n\n    // Division by zero\n    const bad = divide(10, 0)\n\n    match bad {\n        Ok(value) => {\n            print(\"Result: \")\n            print(value)\n            print(\"\\n\")\n        }\n        Err(msg) => {\n            print(\"Error: \")\n            print(msg)\n            print(\"\\n\")\n        }\n    }\n\n    // Using try operator\n    const safe = safe_calc()\n    print(\"Safe calc result: \")\n    print(safe)\n    print(\"\\n\")\n}\n\nfunc divide(a: i32, b: i32) -> i32 or string {\n    if b == 0 {\n        return Err(\"Cannot divide by zero\")\n    }\n    return Ok(a / b)\n}\n\nfunc safe_calc() -> i32 {\n    const x = divide(20, 4)\n    if x is Ok(value) {\n        return value * 2\n    }\n    return 0\n}\n",
    "08_traits": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Learn: Traits and polymorphism\n\n// Define a trait - a shared behavior that types can implement\ntrait Describable {\n    func describe(self) -> string\n}\n\n// Different struct types\nstruct Point {\n    x: i32\n    y: i32\n}\n\nstruct Circle {\n    radius: f64\n}\n\nstruct Person {\n    name: string\n    age: i32\n}\n\n// Implement Describable for Point\nextend Point with Describable {\n    func describe(self) -> string {\n        return format(\"Point({}, {})\", self.x, self.y)\n    }\n}\n\n// Implement Describable for Circle\nextend Circle with Describable {\n    func describe(self) -> string {\n        return format(\"Circle with radius {}\", self.radius)\n    }\n}\n\n// Implement Describable for Person\nextend Person with Describable {\n    func describe(self) -> string {\n        return format(\"{}, age {}\", self.name, self.age)\n    }\n}\n\n// Generic function that works with any Describable type\nfunc print_description<T: Describable>(item: T) {\n    const desc = item.describe()\n    print(desc)\n    print(\"\\n\")\n}\n\n// Function that takes multiple Describable items\nfunc describe_all<T: Describable, U: Describable>(first: T, second: U) {\n    print(\"First: \")\n    print(first.describe())\n    print(\"\\n\")\n\n    print(\"Second: \")\n    print(second.describe())\n    print(\"\\n\")\n}\n\nfunc main() {\n    const point = Point { x: 10, y: 20 }\n    const circle = Circle { radius: 5.5 }\n    const person = Person { name: \"Alice\", age: 30 }\n\n    // Call describe directly\n    print(\"Direct calls:\\n\")\n    print(point.describe())\n    print(\"\\n\")\n    print(circle.describe())\n    print(\"\\n\")\n    print(person.describe())\n    print(\"\\n\\n\")\n\n    // Use generic function - works with any Describable\n    print(\"Via generic function:\\n\")\n    print_description(point)\n    print_description(circle)\n    print_description(person)\n    print(\"\\n\")\n\n    // Mix different types in one function\n    print(\"Mixing types:\\n\")\n    describe_all(point, circle)\n    describe_all(circle, person)\n}\n",
    "09_generics": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Learn: Generic types and functions\n//\n// NOTE: This is a SPEC EXAMPLE showing intended syntax.\n// Not all features are implemented yet (generic extend, closure types).\n// See examples/README.md for status.\n\n// Generic struct with two type parameters\nstruct Pair<T, U> {\n    first: T,\n    second: U,\n}\n\n// Generic struct with one type parameter\nstruct Box<T> {\n    value: T,\n}\n\n// Methods on generic types\nextend<T> Box<T> {\n    func new(value: T) -> Box<T> {\n        return Box { value: value }\n    }\n\n    func get(self) -> T {\n        return self.value\n    }\n}\n\n// Generic function that swaps a pair\nfunc swap<T, U>(pair: Pair<T, U>) -> Pair<U, T> {\n    return Pair {\n        first: pair.second,\n        second: pair.first,\n    }\n}\n\n// Generic function that finds the larger of two values\n// Note: In real Rask, would need Comparable trait constraint\nfunc max_value<T>(a: T, b: T, compare: |T, T| -> bool) -> T {\n    if compare(a, b) {\n        return a\n    }\n    return b\n}\n\n// Generic function with type inference\nfunc wrap<T>(value: T) -> Box<T> {\n    return Box { value: value }\n}\n\n// Generic function that works with any type\nfunc identity<T>(x: T) -> T {\n    return x\n}\n\nfunc main() {\n    // Create pairs with different type combinations\n    const int_string = Pair { first: 42, second: \"hello\" }\n    print(\"Pair: (\")\n    print(int_string.first)\n    print(\", \")\n    print(int_string.second)\n    print(\")\\n\")\n\n    // Swap the pair\n    const string_int = swap(int_string)\n    print(\"Swapped: (\")\n    print(string_int.first)\n    print(\", \")\n    print(string_int.second)\n    print(\")\\n\\n\")\n\n    // Use Box with different types\n    const int_box = Box.new(100)\n    const string_box = Box.new(\"wrapped\")\n\n    print(\"Int box: \")\n    print(int_box.get())\n    print(\"\\n\")\n\n    print(\"String box: \")\n    print(string_box.get())\n    print(\"\\n\\n\")\n\n    // Type inference with wrap\n    const auto_box = wrap(3.14)  // Type inferred as Box<f64>\n    print(\"Auto-wrapped: \")\n    print(auto_box.value)\n    print(\"\\n\\n\")\n\n    // Identity function works with any type\n    const id_int = identity(42)\n    const id_str = identity(\"test\")\n    print(\"Identity int: \")\n    print(id_int)\n    print(\"\\n\")\n    print(\"Identity string: \")\n    print(id_str)\n    print(\"\\n\\n\")\n\n    // Generic max with custom comparator\n    const greater = |a: i32, b: i32| -> bool { return a > b }\n    const max_num = max_value(10, 20, greater)\n    print(\"Max of 10 and 20: \")\n    print(max_num)\n    print(\"\\n\")\n\n    // Works with strings too\n    const str_greater = |a: string, b: string| -> bool {\n        return a.len() > b.len()\n    }\n    const longer = max_value(\"cat\", \"elephant\", str_greater)\n    print(\"Longer word: \")\n    print(longer)\n    print(\"\\n\")\n}\n",
    "10_enums_advanced": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Learn: Enums with associated data\n//\n// NOTE: This is a SPEC EXAMPLE showing intended syntax.\n// Advanced pattern matching not fully implemented yet.\n// See examples/README.md for status.\n\n// Enum with different kinds of variants\nenum Message {\n    Quit,                                    // No data\n    Text(string),                            // Tuple variant\n    Move { x: i32, y: i32 },                 // Struct variant\n    Color { r: i32, g: i32, b: i32 },        // Another struct variant\n}\n\n// Enum representing different shapes\nenum Shape {\n    Circle { radius: f64 },\n    Rectangle { width: f64, height: f64 },\n    Triangle { base: f64, height: f64 },\n}\n\n// Methods on enums\nextend Shape {\n    func area(self) -> f64 {\n        match self {\n            Shape.Circle { radius } => return 3.14159 * radius * radius,\n            Shape.Rectangle { width, height } => return width * height,\n            Shape.Triangle { base, height } => return 0.5 * base * height,\n        }\n    }\n\n    func describe(self) -> string {\n        match self {\n            Shape.Circle { radius } =>\n                return format(\"Circle with radius {}\", radius),\n            Shape.Rectangle { width, height } =>\n                return format(\"Rectangle {}x{}\", width, height),\n            Shape.Triangle { base, height } =>\n                return format(\"Triangle (base={}, height={})\", base, height),\n        }\n    }\n}\n\n// Function that processes messages\nfunc handle_message(msg: Message) {\n    match msg {\n        Message.Quit => {\n            print(\"Received quit signal\\n\")\n        }\n        Message.Text(content) => {\n            print(\"Text message: \")\n            print(content)\n            print(\"\\n\")\n        }\n        Message.Move { x, y } => {\n            print(\"Move to position (\")\n            print(x)\n            print(\", \")\n            print(y)\n            print(\")\\n\")\n        }\n        Message.Color { r, g, b } => {\n            print(\"Set color to RGB(\")\n            print(r)\n            print(\", \")\n            print(g)\n            print(\", \")\n            print(b)\n            print(\")\\n\")\n        }\n    }\n}\n\nfunc main() {\n    // Create different message variants\n    const messages = Vec.from([\n        Message.Text(\"Hello, Rask!\"),\n        Message.Move { x: 10, y: 20 },\n        Message.Color { r: 255, g: 128, b: 0 },\n        Message.Quit,\n    ])\n\n    print(\"Processing messages:\\n\")\n    for msg in messages.iter() {\n        handle_message(msg)\n    }\n\n    print(\"\\n\")\n\n    // Create different shapes\n    const circle = Shape.Circle { radius: 5.0 }\n    const rectangle = Shape.Rectangle { width: 4.0, height: 6.0 }\n    const triangle = Shape.Triangle { base: 3.0, height: 4.0 }\n\n    // Calculate and display areas\n    print(\"Shape areas:\\n\")\n\n    print(circle.describe())\n    print(\" - Area: \")\n    print(circle.area())\n    print(\"\\n\")\n\n    print(rectangle.describe())\n    print(\" - Area: \")\n    print(rectangle.area())\n    print(\"\\n\")\n\n    print(triangle.describe())\n    print(\" - Area: \")\n    print(triangle.area())\n    print(\"\\n\\n\")\n\n    // Pattern matching to extract values\n    const my_shape = Shape.Rectangle { width: 10.0, height: 5.0 }\n\n    match my_shape {\n        Shape.Circle { radius } => {\n            print(\"It's a circle with radius \")\n            print(radius)\n            print(\"\\n\")\n        }\n        Shape.Rectangle { width, height } => {\n            print(\"It's a rectangle: \")\n            print(width)\n            print(\" x \")\n            print(height)\n            print(\"\\n\")\n        }\n        Shape.Triangle { base, height } => {\n            print(\"It's a triangle\\n\")\n        }\n    }\n}\n",
    "11_closures": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Learn: Closures and function types\n//\n// NOTE: This is a SPEC EXAMPLE showing intended syntax.\n// Full closure syntax not yet implemented.\n// See examples/README.md for status.\n\n// Function that takes a closure as a parameter\nfunc apply(f: |i32| -> i32, value: i32) -> i32 {\n    return f(value)\n}\n\n// Function that takes two parameters\nfunc apply_binary(f: |i32, i32| -> i32, a: i32, b: i32) -> i32 {\n    return f(a, b)\n}\n\n// Higher-order function that returns a closure\nfunc make_adder(amount: i32) -> |i32| -> i32 {\n    return |x: i32| -> i32 { return x + amount }\n}\n\n// Function that applies a function twice\nfunc apply_twice(f: |i32| -> i32, x: i32) -> i32 {\n    return f(f(x))\n}\n\n// Function that filters a vector based on a predicate\nfunc filter_vec(vec: Vec<i32>, predicate: |i32| -> bool) -> Vec<i32> {\n    const result = Vec.new()\n    for item in vec.iter() {\n        if predicate(item) {\n            result.push(item)\n        }\n    }\n    return result\n}\n\nfunc main() {\n    // Simple closure - inline function\n    const double = |x: i32| -> i32 { return x * 2 }\n    const squared = |x: i32| -> i32 { return x * x }\n\n    print(\"Double 5: \")\n    print(double(5))\n    print(\"\\n\")\n\n    print(\"Square 5: \")\n    print(squared(5))\n    print(\"\\n\\n\")\n\n    // Pass closure to function\n    const result1 = apply(double, 10)\n    print(\"Apply double to 10: \")\n    print(result1)\n    print(\"\\n\")\n\n    const result2 = apply(squared, 7)\n    print(\"Apply squared to 7: \")\n    print(result2)\n    print(\"\\n\\n\")\n\n    // Multi-parameter closures\n    const add = |a: i32, b: i32| -> i32 { return a + b }\n    const multiply = |a: i32, b: i32| -> i32 { return a * b }\n\n    print(\"5 + 3 = \")\n    print(apply_binary(add, 5, 3))\n    print(\"\\n\")\n\n    print(\"5 * 3 = \")\n    print(apply_binary(multiply, 5, 3))\n    print(\"\\n\\n\")\n\n    // Capturing variables from outer scope\n    const multiplier = 10\n    const scale = |x: i32| -> i32 { return x * multiplier }\n\n    print(\"Scale 5 by \")\n    print(multiplier)\n    print(\": \")\n    print(scale(5))\n    print(\"\\n\\n\")\n\n    // Closure factory - returns a closure\n    const add_5 = make_adder(5)\n    const add_100 = make_adder(100)\n\n    print(\"Add 5 to 10: \")\n    print(add_5(10))\n    print(\"\\n\")\n\n    print(\"Add 100 to 10: \")\n    print(add_100(10))\n    print(\"\\n\\n\")\n\n    // Apply function twice\n    const increment = |x: i32| -> i32 { return x + 1 }\n    const twice = apply_twice(increment, 5)\n    print(\"Increment 5 twice: \")\n    print(twice)\n    print(\"\\n\\n\")\n\n    // Filter with predicate\n    const numbers = Vec.from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n    const is_even = |n: i32| -> bool { return n % 2 == 0 }\n    const evens = filter_vec(numbers, is_even)\n\n    print(\"Even numbers: \")\n    for n in evens.iter() {\n        print(n)\n        print(\" \")\n    }\n    print(\"\\n\")\n\n    const is_greater_than_5 = |n: i32| -> bool { return n > 5 }\n    const large = filter_vec(numbers, is_greater_than_5)\n\n    print(\"Numbers > 5: \")\n    for n in large.iter() {\n        print(n)\n        print(\" \")\n    }\n    print(\"\\n\")\n\n    // Inline closure - no need to name it\n    const odd = filter_vec(numbers, |n: i32| -> bool { return n % 2 == 1 })\n    print(\"Odd numbers: \")\n    for n in odd.iter() {\n        print(n)\n        print(\" \")\n    }\n    print(\"\\n\")\n}\n",
    "12_iterators": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Learn: Iterator patterns and functional chains\n//\n// NOTE: This is a SPEC EXAMPLE showing intended syntax.\n// Iterator trait and method chaining not fully implemented yet.\n// See examples/README.md for status.\n\nfunc main() {\n    const numbers = Vec.from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n    // Basic iteration\n    print(\"All numbers: \")\n    for n in numbers.iter() {\n        print(n)\n        print(\" \")\n    }\n    print(\"\\n\\n\")\n\n    // Map - transform each element\n    const doubled = numbers.iter()\n        .map(|n| n * 2)\n        .collect()\n\n    print(\"Doubled: \")\n    for n in doubled.iter() {\n        print(n)\n        print(\" \")\n    }\n    print(\"\\n\")\n\n    const squared = numbers.iter()\n        .map(|n| n * n)\n        .collect()\n\n    print(\"Squared: \")\n    for n in squared.iter() {\n        print(n)\n        print(\" \")\n    }\n    print(\"\\n\\n\")\n\n    // Filter - keep only elements that match predicate\n    const evens = numbers.iter()\n        .filter(|n| n % 2 == 0)\n        .collect()\n\n    print(\"Even numbers: \")\n    for n in evens.iter() {\n        print(n)\n        print(\" \")\n    }\n    print(\"\\n\")\n\n    const large = numbers.iter()\n        .filter(|n| n > 5)\n        .collect()\n\n    print(\"Numbers > 5: \")\n    for n in large.iter() {\n        print(n)\n        print(\" \")\n    }\n    print(\"\\n\\n\")\n\n    // Chain multiple operations\n    const result = numbers.iter()\n        .filter(|n| n % 2 == 0)  // Keep evens\n        .map(|n| n * n)           // Square them\n        .collect()\n\n    print(\"Even numbers squared: \")\n    for n in result.iter() {\n        print(n)\n        print(\" \")\n    }\n    print(\"\\n\\n\")\n\n    // Skip and take\n    const middle = numbers.iter()\n        .skip(3)   // Skip first 3\n        .take(4)   // Take next 4\n        .collect()\n\n    print(\"Middle section (skip 3, take 4): \")\n    for n in middle.iter() {\n        print(n)\n        print(\" \")\n    }\n    print(\"\\n\\n\")\n\n    // Complex chain\n    const complex = numbers.iter()\n        .skip(1)                  // Skip first element\n        .filter(|n| n < 8)        // Keep elements < 8\n        .map(|n| n * 3)           // Triple them\n        .filter(|n| n > 10)       // Keep only results > 10\n        .collect()\n\n    print(\"Complex chain result: \")\n    for n in complex.iter() {\n        print(n)\n        print(\" \")\n    }\n    print(\"\\n\\n\")\n\n    // Fold - reduce to a single value\n    const sum = numbers.iter()\n        .fold(0, |acc, n| acc + n)\n\n    print(\"Sum of all numbers: \")\n    print(sum)\n    print(\"\\n\")\n\n    const product = numbers.iter()\n        .take(5)\n        .fold(1, |acc, n| acc * n)\n\n    print(\"Product of first 5: \")\n    print(product)\n    print(\"\\n\\n\")\n\n    // Find - get first element matching predicate\n    const first_large = numbers.iter()\n        .find(|n| n > 7)\n\n    match first_large {\n        Some(n) => {\n            print(\"First number > 7: \")\n            print(n)\n            print(\"\\n\")\n        }\n        None => print(\"Not found\\n\")\n    }\n\n    // Any/all predicates\n    const has_even = numbers.iter()\n        .any(|n| n % 2 == 0)\n\n    print(\"Has even numbers: \")\n    if has_even {\n        print(\"yes\\n\")\n    } else {\n        print(\"no\\n\")\n    }\n\n    const all_positive = numbers.iter()\n        .all(|n| n > 0)\n\n    print(\"All positive: \")\n    if all_positive {\n        print(\"yes\\n\")\n    } else {\n        print(\"no\\n\")\n    }\n\n    print(\"\\n\")\n\n    // Working with strings\n    const words = Vec.from([\"hello\", \"world\", \"rask\", \"language\"])\n\n    const uppercase = words.iter()\n        .map(|s| s.to_uppercase())\n        .collect()\n\n    print(\"Uppercase words: \")\n    for word in uppercase.iter() {\n        print(word)\n        print(\" \")\n    }\n    print(\"\\n\")\n\n    const long_words = words.iter()\n        .filter(|s| s.len() > 4)\n        .collect()\n\n    print(\"Words longer than 4 chars: \")\n    for word in long_words.iter() {\n        print(word)\n        print(\" \")\n    }\n    print(\"\\n\")\n}\n",
    "13_string_operations": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Learn: String methods and parsing\n\nfunc main() {\n    // Basic string creation\n    const greeting = \"Hello, Rask!\"\n    print(\"Original: \")\n    print(greeting)\n    print(\"\\n\\n\")\n\n    // String length\n    print(\"Length: \")\n    print(greeting.len())\n    print(\"\\n\\n\")\n\n    // Case conversion\n    const lower = greeting.to_lowercase()\n    const upper = greeting.to_uppercase()\n\n    print(\"Lowercase: \")\n    print(lower)\n    print(\"\\n\")\n\n    print(\"Uppercase: \")\n    print(upper)\n    print(\"\\n\\n\")\n\n    // Trimming whitespace\n    const messy = \"   spaces everywhere   \"\n    print(\"Original: '\")\n    print(messy)\n    print(\"'\\n\")\n\n    const trimmed = messy.trim()\n    print(\"Trimmed: '\")\n    print(trimmed)\n    print(\"'\\n\")\n\n    const trim_start = messy.trim_start()\n    print(\"Trim start: '\")\n    print(trim_start)\n    print(\"'\\n\")\n\n    const trim_end = messy.trim_end()\n    print(\"Trim end: '\")\n    print(trim_end)\n    print(\"'\\n\\n\")\n\n    // Checking content\n    const text = \"The quick brown fox\"\n\n    if text.contains(\"quick\") {\n        print(\"Contains 'quick'\\n\")\n    }\n\n    if text.starts_with(\"The\") {\n        print(\"Starts with 'The'\\n\")\n    }\n\n    if text.ends_with(\"fox\") {\n        print(\"Ends with 'fox'\\n\")\n    }\n    print(\"\\n\")\n\n    // Splitting strings\n    const sentence = \"one two three four five\"\n    const words = sentence.split_whitespace()\n\n    print(\"Words: \")\n    for word in words.iter() {\n        print(\"[\")\n        print(word)\n        print(\"] \")\n    }\n    print(\"\\n\\n\")\n\n    // Split by delimiter\n    const csv = \"apple,banana,orange,grape\"\n    const fruits = csv.split(\",\")\n\n    print(\"Fruits: \")\n    for fruit in fruits.iter() {\n        print(fruit)\n        print(\" \")\n    }\n    print(\"\\n\\n\")\n\n    // String slicing\n    const full = \"Hello, World!\"\n    const slice1 = full[0..5]    // \"Hello\"\n    const slice2 = full[7..]     // \"World!\"\n\n    print(\"Slice [0..5]: \")\n    print(slice1)\n    print(\"\\n\")\n\n    print(\"Slice [7..]: \")\n    print(slice2)\n    print(\"\\n\\n\")\n\n    // String formatting\n    const name = \"Alice\"\n    const age = 30\n    const formatted = format(\"Name: {}, Age: {}\", name, age)\n\n    print(formatted)\n    print(\"\\n\\n\")\n\n    // Multiple format arguments\n    const x = 10\n    const y = 20\n    const msg = format(\"Point ({}, {})\", x, y)\n    print(msg)\n    print(\"\\n\\n\")\n\n    // Parsing strings to numbers\n    const num_str = \"42\"\n    const parsed = num_str.parse<i32>()\n\n    match parsed {\n        Ok(num) => {\n            print(\"Parsed number: \")\n            print(num)\n            print(\"\\n\")\n        }\n        Err(e) => {\n            print(\"Parse error: \")\n            print(e)\n            print(\"\\n\")\n        }\n    }\n\n    // Parsing with error handling\n    const bad_str = \"not a number\"\n    const bad_parsed = bad_str.parse<i32>()\n\n    match bad_parsed {\n        Ok(num) => {\n            print(\"This shouldn't happen\\n\")\n        }\n        Err(e) => {\n            print(\"Expected error: \")\n            print(e)\n            print(\"\\n\")\n        }\n    }\n\n    print(\"\\n\")\n\n    // String concatenation\n    const first = \"Hello\"\n    const second = \"World\"\n    const combined = format(\"{} {}\", first, second)\n\n    print(\"Combined: \")\n    print(combined)\n    print(\"\\n\\n\")\n\n    // Working with individual characters\n    const alpha = \"abc\"\n    print(\"Iterating chars: \")\n    for c in alpha.chars() {\n        print(c)\n        print(\" \")\n    }\n    print(\"\\n\\n\")\n\n    // String replacement\n    const original = \"foo bar foo\"\n    const replaced = original.replace(\"foo\", \"baz\")\n\n    print(\"Original: \")\n    print(original)\n    print(\"\\n\")\n\n    print(\"Replaced: \")\n    print(replaced)\n    print(\"\\n\\n\")\n\n    // Repeating strings\n    const pattern = \"ab\"\n    const repeated = pattern.repeat(3)\n\n    print(\"Repeated: \")\n    print(repeated)\n    print(\"\\n\")\n}\n",
    "14_borrowing_patterns": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Learn: Borrowing patterns in Rask\n//\n// NOTE: This is a SPEC EXAMPLE showing intended syntax.\n// Borrow checker and reference types not fully implemented yet.\n// See examples/README.md for status.\n\nstruct User {\n    name: string,\n    age: i32,\n}\n\nfunc print_user(user: &User) {\n    print(\"User: \")\n    print(user.name)\n    print(\", age \")\n    print(user.age)\n    print(\"\\n\")\n}\n\nfunc get_age(user: &User) -> i32 {\n    return user.age\n}\n\nfunc main() {\n    // Expression-scoped borrowing with collections\n    // Collections are borrowed only during method call\n    const numbers = Vec.from([1, 2, 3, 4, 5])\n\n    // Borrow happens during .iter() call, ends immediately\n    const sum = numbers.iter().fold(0, |acc, x| acc + x)\n\n    // Can use numbers again immediately\n    print(\"Sum: \")\n    print(sum)\n    print(\"\\n\")\n\n    print(\"Count: \")\n    print(numbers.len())\n    print(\"\\n\\n\")\n\n    // Multiple borrows in sequence\n    const first = numbers.iter().find(|x| x > 0)\n    const last = numbers.iter().find(|x| x == 5)\n\n    match first {\n        Some(n) => {\n            print(\"First: \")\n            print(n)\n            print(\"\\n\")\n        }\n        None => print(\"No first\\n\")\n    }\n\n    // Block-scoped borrowing with values\n    const user = User { name: \"Alice\", age: 30 }\n\n    {\n        const borrowed = &user\n        print_user(borrowed)\n        print(\"Age: \")\n        print(borrowed.age)\n        print(\"\\n\")\n    }  // Borrow ends here\n\n    // user is accessible again after block\n    print(\"User name: \")\n    print(user.name)\n    print(\"\\n\\n\")\n\n    // Multiple immutable borrows are allowed\n    const user2 = User { name: \"Bob\", age: 25 }\n\n    {\n        const ref1 = &user2\n        const ref2 = &user2  // OK - multiple immutable borrows\n\n        print_user(ref1)\n        print_user(ref2)\n    }\n\n    print(\"\\n\")\n\n    // Passing borrowed values to functions\n    const alice = User { name: \"Alice\", age: 35 }\n\n    print_user(&alice)\n\n    const age = get_age(&alice)\n    print(\"Retrieved age: \")\n    print(age)\n    print(\"\\n\\n\")\n\n    // Iterating with borrows\n    const users = Vec.from([\n        User { name: \"Charlie\", age: 40 },\n        User { name: \"Diana\", age: 28 },\n        User { name: \"Eve\", age: 32 },\n    ])\n\n    print(\"All users:\\n\")\n    for user in users.iter() {\n        print_user(user)  // Each user is borrowed during iteration\n    }\n\n    print(\"\\n\")\n\n    // Collection can be used after iteration\n    print(\"Total users: \")\n    print(users.len())\n    print(\"\\n\\n\")\n\n    // Borrow for comparison\n    const vec1 = Vec.from([1, 2, 3])\n    const vec2 = Vec.from([1, 2, 3])\n\n    // Borrowing happens during comparison only\n    if vec1.iter().eq(vec2.iter()) {\n        print(\"Vectors are equal\\n\")\n    }\n\n    // Both still usable\n    print(\"Vec1 length: \")\n    print(vec1.len())\n    print(\"\\n\")\n\n    print(\"Vec2 length: \")\n    print(vec2.len())\n    print(\"\\n\\n\")\n\n    // When you need ownership instead of borrowing\n    // Use .clone() to create a copy\n    const original = Vec.from([10, 20, 30])\n    const copy = original.clone()\n\n    // Both are independent now\n    print(\"Original: \")\n    for n in original.iter() {\n        print(n)\n        print(\" \")\n    }\n    print(\"\\n\")\n\n    print(\"Copy: \")\n    for n in copy.iter() {\n        print(n)\n        print(\" \")\n    }\n    print(\"\\n\\n\")\n\n    // Pattern: borrow in expression, use immediately\n    const data = Vec.from([5, 2, 8, 1, 9])\n\n    const max = data.iter()\n        .fold(0, |acc, x| {\n            if x > acc {\n                return x\n            }\n            return acc\n        })\n\n    print(\"Max value: \")\n    print(max)\n    print(\"\\n\")\n\n    // data is still available\n    print(\"Data length: \")\n    print(data.len())\n    print(\"\\n\")\n}\n",
    "15_memory_management": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Learn: Memory management with Pool and Handle\n//\n// NOTE: This is a SPEC EXAMPLE showing intended syntax.\n// Generic Pool and Handle types not fully implemented yet.\n// See examples/README.md for status.\n\n// Node in a linked list - uses Handle instead of references\nstruct Node {\n    value: i32\n    next: Handle<Node>?,  // Optional handle to next node\n}\n\n// Entity in a game or simulation\nstruct Entity {\n    id: i32\n    name: string\n    health: i32\n    target: Handle<Entity>?,  // Optional handle to target entity\n}\n\nfunc main() {\n    print(\"=== Pool/Handle Pattern ===\\n\\n\")\n\n    // Problem: References can dangle\n    // Solution: Pool<T> allocates, Handle<T> refers\n    // Handles remain valid even if pool reorganizes memory\n\n    // Create a pool for nodes\n    const node_pool = Pool<Node>.new()\n\n    print(\"Creating linked list with handles:\\n\")\n\n    // Allocate nodes in the pool\n    const first = node_pool.alloc(Node {\n        value: 1,\n        next: None,\n    })\n\n    const second = node_pool.alloc(Node {\n        value: 2,\n        next: None,\n    })\n\n    const third = node_pool.alloc(Node {\n        value: 3,\n        next: None,\n    })\n\n    // Link nodes using handles\n    node_pool.get_mut(first).next = Some(second)\n    node_pool.get_mut(second).next = Some(third)\n\n    // Traverse the list using handles\n    print(\"List values: \")\n    let current = Some(first)\n\n    loop {\n        if current is Some(handle) {\n            const node = node_pool.get(handle)\n            print(node.value)\n            print(\" -> \")\n            current = node.next\n        } else {\n            print(\"end\\n\\n\")\n            deliver ()\n        }\n    }\n\n    // Create entity pool for game-like scenario\n    const entities = Pool<Entity>.new()\n\n    print(\"Creating game entities:\\n\")\n\n    const player = entities.alloc(Entity {\n        id: 1,\n        name: \"Player\",\n        health: 100,\n        target: None,\n    })\n\n    const enemy1 = entities.alloc(Entity {\n        id: 2,\n        name: \"Goblin\",\n        health: 50,\n        target: Some(player),  // Enemy targets player\n    })\n\n    const enemy2 = entities.alloc(Entity {\n        id: 3,\n        name: \"Orc\",\n        health: 80,\n        target: Some(player),\n    })\n\n    // Player targets first enemy\n    entities.get_mut(player).target = Some(enemy1)\n\n    // Display entity relationships\n    print(\"\\nEntity relationships:\\n\")\n\n    const player_ent = entities.get(player)\n    print(player_ent.name)\n    print(\" (HP: \")\n    print(player_ent.health)\n    print(\")\")\n\n    if player_ent.target is Some(target_handle) {\n        const target = entities.get(target_handle)\n        print(\" -> targets \")\n        print(target.name)\n    }\n    print(\"\\n\")\n\n    const e1 = entities.get(enemy1)\n    print(e1.name)\n    print(\" (HP: \")\n    print(e1.health)\n    print(\")\")\n\n    if e1.target is Some(target_handle) {\n        const target = entities.get(target_handle)\n        print(\" -> targets \")\n        print(target.name)\n    }\n    print(\"\\n\")\n\n    const e2 = entities.get(enemy2)\n    print(e2.name)\n    print(\" (HP: \")\n    print(e2.health)\n    print(\")\")\n\n    if e2.target is Some(target_handle) {\n        const target = entities.get(target_handle)\n        print(\" -> targets \")\n        print(target.name)\n    }\n    print(\"\\n\\n\")\n\n    // Modify entities through handles\n    print(\"Applying damage:\\n\")\n\n    entities.get_mut(enemy1).health = entities.get(enemy1).health - 20\n    print(\"Goblin health: \")\n    print(entities.get(enemy1).health)\n    print(\"\\n\")\n\n    entities.get_mut(player).health = entities.get(player).health - 10\n    print(\"Player health: \")\n    print(entities.get(player).health)\n    print(\"\\n\\n\")\n\n    // Handle invalidation - removing entities\n    print(\"Removing defeated enemy:\\n\")\n\n    entities.free(enemy1)  // Free the goblin\n\n    // Player's target handle is now invalid\n    // In a real system, you'd clear dangling handles\n    print(\"Enemy1 removed from pool\\n\\n\")\n\n    // Why Pool/Handle instead of references?\n    // 1. No lifetime annotations needed\n    // 2. Handles stay valid across pool reorganization\n    // 3. Can have cycles (node.next can refer back)\n    // 4. Clear ownership (pool owns all data)\n    // 5. Easy to invalidate handles when removing items\n\n    print(\"=== Key Benefits ===\\n\")\n    print(\"- No lifetime parameters\\n\")\n    print(\"- Handles never dangle (invalidation explicit)\\n\")\n    print(\"- Perfect for graphs, entity systems, UI trees\\n\")\n    print(\"- Pool owns memory, handles are lightweight IDs\\n\")\n}\n",
    "16_concurrency_basics": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Learn: Concurrency with threads and channels\n\nfunc worker(id: i32, iterations: i32) -> i32 {\n    print(\"Worker \")\n    print(id)\n    print(\" starting\\n\")\n\n    let sum = 0\n    for i in 1..iterations + 1 {\n        sum = sum + i\n    }\n\n    print(\"Worker \")\n    print(id)\n    print(\" done, sum = \")\n    print(sum)\n    print(\"\\n\")\n\n    return sum\n}\n\nfunc main() {\n    print(\"=== Basic Threading ===\\n\\n\")\n\n    // Spawn a thread with spawn { }\n    // Returns a ThreadHandle\n    const handle = spawn {\n        print(\"Hello from thread!\\n\")\n        return 42\n    }\n\n    print(\"Main thread continues...\\n\")\n\n    // Wait for thread to complete with .join()\n    const result = try handle.join()\n    print(\"Thread returned: \")\n    print(result)\n    print(\"\\n\\n\")\n\n    // Spawn multiple threads\n    print(\"=== Multiple Threads ===\\n\\n\")\n\n    const h1 = spawn { return worker(1, 10) }\n    const h2 = spawn { return worker(2, 20) }\n    const h3 = spawn { return worker(3, 15) }\n\n    // Wait for all threads\n    const r1 = try h1.join()\n    const r2 = try h2.join()\n    const r3 = try h3.join()\n\n    const total = r1 + r2 + r3\n    print(\"\\nTotal: \")\n    print(total)\n    print(\"\\n\\n\")\n\n    // Detaching threads - fire and forget\n    print(\"=== Detached Threads ===\\n\\n\")\n\n    const detached = spawn {\n        print(\"I'm a detached thread!\\n\")\n        return 0\n    }\n\n    detached.detach()  // Don't wait for it\n    print(\"Detached thread running in background\\n\\n\")\n\n    // Channels for communication\n    print(\"=== Channels ===\\n\\n\")\n\n    const channel = Channel.buffered<string>(5)\n\n    // Spawn producer thread\n    const producer = spawn {\n        try channel.sender.send(\"Message 1\")\n        try channel.sender.send(\"Message 2\")\n        try channel.sender.send(\"Message 3\")\n        print(\"Producer sent 3 messages\\n\")\n        return 0\n    }\n\n    // Spawn consumer thread\n    const consumer = spawn {\n        const msg1 = try channel.receiver.recv()\n        print(\"Received: \")\n        print(msg1)\n        print(\"\\n\")\n\n        const msg2 = try channel.receiver.recv()\n        print(\"Received: \")\n        print(msg2)\n        print(\"\\n\")\n\n        const msg3 = try channel.receiver.recv()\n        print(\"Received: \")\n        print(msg3)\n        print(\"\\n\")\n\n        return 0\n    }\n\n    try producer.join()\n    try consumer.join()\n    print(\"\\n\")\n\n    // Unbuffered channel - synchronous\n    print(\"=== Unbuffered Channel ===\\n\\n\")\n\n    const sync_channel = Channel.unbuffered<i32>()\n\n    const sender_thread = spawn {\n        print(\"Sending 100...\\n\")\n        try sync_channel.sender.send(100)  // Blocks until received\n        print(\"Send complete\\n\")\n        return 0\n    }\n\n    const receiver_thread = spawn {\n        print(\"Waiting to receive...\\n\")\n        const value = try sync_channel.receiver.recv()  // Blocks until sent\n        print(\"Received: \")\n        print(value)\n        print(\"\\n\")\n        return 0\n    }\n\n    try sender_thread.join()\n    try receiver_thread.join()\n    print(\"\\n\")\n\n    // Try receive - non-blocking\n    print(\"=== Non-blocking Receive ===\\n\\n\")\n\n    const test_channel = Channel.buffered<i32>(2)\n\n    // Send one message\n    try test_channel.sender.send(999)\n\n    // Try to receive\n    const maybe_msg = test_channel.receiver.try_recv()\n\n    match maybe_msg {\n        Ok(value) => {\n            print(\"Got message: \")\n            print(value)\n            print(\"\\n\")\n        }\n        Err(e) => {\n            print(\"No message available\\n\")\n        }\n    }\n\n    // Try to receive again (should fail, channel empty)\n    const no_msg = test_channel.receiver.try_recv()\n\n    match no_msg {\n        Ok(value) => {\n            print(\"Got message: \")\n            print(value)\n            print(\"\\n\")\n        }\n        Err(e) => {\n            print(\"Channel empty (expected)\\n\")\n        }\n    }\n\n    print(\"\\n\")\n\n    // Thread pool with 'with threading'\n    print(\"=== Thread Pool ===\\n\\n\")\n\n    with threading(4) {\n        const handles = Vec.new()\n\n        for i in 0..8 {\n            const h = spawn_thread {\n                print(\"Pool task \")\n                print(i)\n                print(\" running\\n\")\n                return i * i\n            }\n            handles.push(h)\n        }\n\n        print(\"\\nWaiting for all pool tasks...\\n\")\n\n        for handle in handles.iter() {\n            const res = try handle.join()\n            print(\"Task result: \")\n            print(res)\n            print(\"\\n\")\n        }\n    }  // Thread pool shuts down here\n\n    print(\"\\n=== Key Points ===\\n\")\n    print(\"- spawn { } creates OS threads\\n\")\n    print(\"- handle.join() waits for completion\\n\")\n    print(\"- handle.detach() runs in background\\n\")\n    print(\"- Channels enable message passing\\n\")\n    print(\"- No data races - compiler enforces safety\\n\")\n    print(\"- No function coloring - threads are first-class\\n\")\n}\n",
    "17_comptime": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Learn: Compile-time execution with comptime\n\n// Compute squares at compile time\nconst SQUARES = comptime {\n    const arr = Vec.new()\n    for i in 0..20 {\n        arr.push(i * i)\n    }\n    deliver arr\n}\n\n// Fibonacci lookup table\nconst FIBONACCI = comptime {\n    const fib = Vec.new()\n    fib.push(0)\n    fib.push(1)\n\n    for i in 2..15 {\n        const prev1 = fib[i - 1]\n        const prev2 = fib[i - 2]\n        fib.push(prev1 + prev2)\n    }\n\n    deliver fib\n}\n\n// Powers of two\nconst POWERS_OF_TWO = comptime {\n    const powers = Vec.new()\n    let power = 1\n    for i in 0..16 {\n        powers.push(power)\n        power = power * 2\n    }\n    deliver powers\n}\n\n// Prime numbers up to 50\nconst PRIMES = comptime {\n    const primes = Vec.new()\n\n    for n in 2..50 {\n        let is_prime = true\n\n        for i in 2..n {\n            if i * i > n {\n                deliver ()  // Break early\n            }\n            if n % i == 0 {\n                is_prime = false\n                deliver ()  // Break\n            }\n        }\n\n        if is_prime {\n            primes.push(n)\n        }\n    }\n\n    deliver primes\n}\n\nfunc main() {\n    print(\"=== Compile-Time Computation ===\\n\\n\")\n\n    // These values were computed at compile time - zero runtime cost\n    print(\"Squares (computed at compile time):\\n\")\n    for i in 0..10 {\n        print(\"Square of \")\n        print(i)\n        print(\" = \")\n        print(SQUARES[i])\n        print(\"\\n\")\n    }\n\n    print(\"\\nFibonacci sequence:\\n\")\n    for i in 0..FIBONACCI.len() {\n        print(\"fib(\")\n        print(i)\n        print(\") = \")\n        print(FIBONACCI[i])\n        print(\"\\n\")\n    }\n\n    print(\"\\nPowers of two:\\n\")\n    for i in 0..10 {\n        print(\"2^\")\n        print(i)\n        print(\" = \")\n        print(POWERS_OF_TWO[i])\n        print(\"\\n\")\n    }\n\n    print(\"\\nPrime numbers up to 50:\\n\")\n    for prime in PRIMES.iter() {\n        print(prime)\n        print(\" \")\n    }\n    print(\"\\n\\n\")\n\n    // Comptime for conditional compilation\n    const IS_DEBUG = comptime { deliver true }\n\n    if IS_DEBUG {\n        print(\"Debug mode enabled\\n\")\n    }\n\n    print(\"\\n\")\n\n    // Use comptime values for fast lookup\n    const index = 7\n    print(\"Looking up square of \")\n    print(index)\n    print(\": \")\n    print(SQUARES[index])\n    print(\" (no computation at runtime)\\n\\n\")\n\n    // Comptime for generating constants\n    const BUFFER_SIZE = comptime {\n        // Could be based on platform, configuration, etc.\n        deliver 1024\n    }\n\n    print(\"Buffer size: \")\n    print(BUFFER_SIZE)\n    print(\" (determined at compile time)\\n\\n\")\n\n    print(\"=== Key Benefits ===\\n\")\n    print(\"- Zero runtime cost for computed values\\n\")\n    print(\"- Perfect for lookup tables, constants\\n\")\n    print(\"- Runs during compilation, not at runtime\\n\")\n    print(\"- Can use full language features\\n\")\n    print(\"- Great for performance-critical code\\n\")\n}\n",
    "18_resource_types": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Learn: Linear resources with @resource and ensure\n\n// Linear resource must be explicitly consumed\n@resource\nstruct Transaction {\n    id: i32\n    amount: i32\n    committed: bool\n}\n\nextend Transaction {\n    // Consumes the transaction (take self)\n    func commit(take self) {\n        print(\"Committing transaction \")\n        print(self.id)\n        print(\" for $\")\n        print(self.amount)\n        print(\"\\n\")\n    }\n\n    // Alternative: rollback instead of commit\n    func rollback(take self) {\n        print(\"Rolling back transaction \")\n        print(self.id)\n        print(\"\\n\")\n    }\n}\n\n// Another linear resource\n@resource\nstruct Connection {\n    host: string\n    port: i32\n}\n\nextend Connection {\n    func close(take self) {\n        print(\"Closing connection to \")\n        print(self.host)\n        print(\":\")\n        print(self.port)\n        print(\"\\n\")\n    }\n\n    func send(self, msg: string) {\n        print(\"Sending: \")\n        print(msg)\n        print(\" to \")\n        print(self.host)\n        print(\"\\n\")\n    }\n}\n\nfunc successful_payment() {\n    print(\"\\n=== Successful Payment ===\\n\")\n\n    const tx = Transaction {\n        id: 1,\n        amount: 100,\n        committed: false,\n    }\n\n    // Ensure cleanup if function exits early\n    ensure tx.rollback()\n\n    print(\"Processing payment...\\n\")\n\n    // Everything succeeded, commit explicitly\n    tx.commit()  // This consumes the transaction\n\n    // ensure won't run because tx was already consumed\n}\n\nfunc failed_payment() {\n    print(\"\\n=== Failed Payment ===\\n\")\n\n    const tx = Transaction {\n        id: 2,\n        amount: 200,\n        committed: false,\n    }\n\n    ensure tx.rollback()\n\n    print(\"Processing payment...\\n\")\n    print(\"Payment failed!\\n\")\n\n    // Function exits without commit\n    // ensure will run and rollback\n}\n\nfunc network_operation() {\n    print(\"\\n=== Network Operation ===\\n\")\n\n    const conn = Connection {\n        host: \"example.com\",\n        port: 8080,\n    }\n\n    ensure conn.close()\n\n    conn.send(\"Hello\")\n    conn.send(\"World\")\n\n    // Connection closes automatically via ensure\n}\n\nfunc manual_close() {\n    print(\"\\n=== Manual Close ===\\n\")\n\n    const conn = Connection {\n        host: \"api.example.com\",\n        port: 443,\n    }\n\n    ensure conn.close()\n\n    conn.send(\"GET /data\")\n\n    // Close manually before ensure runs\n    conn.close()\n\n    print(\"After manual close\\n\")\n    // ensure won't run because conn was already closed\n}\n\nfunc main() {\n    print(\"=== Linear Resources ===\\n\")\n    print(\"Resources marked with @resource must be consumed\\n\")\n    print(\"Use 'ensure' for automatic cleanup\\n\")\n\n    successful_payment()\n    failed_payment()\n    network_operation()\n    manual_close()\n\n    print(\"\\n=== Files as Resources ===\\n\")\n\n    // File handles are also linear resources\n    const file = try fs.open(\"test.txt\")\n    ensure file.close()\n\n    // Use the file\n    const content = try file.read_to_string()\n    print(\"File content: \")\n    print(content)\n    print(\"\\n\")\n\n    // file.close() runs via ensure\n\n    print(\"\\n=== Key Points ===\\n\")\n    print(\"- @resource types must be explicitly consumed\\n\")\n    print(\"- Prevents resource leaks at compile time\\n\")\n    print(\"- 'ensure' guarantees cleanup on all exit paths\\n\")\n    print(\"- Methods with 'take self' consume the resource\\n\")\n    print(\"- Compiler error if resource not consumed\\n\")\n\n    print(\"\\n=== What This Prevents ===\\n\")\n    print(\"- Forgetting to close files\\n\")\n    print(\"- Forgetting to commit/rollback transactions\\n\")\n    print(\"- Forgetting to release locks\\n\")\n    print(\"- Forgetting to close network connections\\n\")\n    print(\"- All checked at compile time!\\n\")\n}\n",
    "19_unsafe": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Learn: Unsafe blocks and C FFI\n//\n// NOTE: This is a SPEC EXAMPLE showing intended syntax.\n// Unsafe blocks, pointer operations, and FFI not yet implemented.\n// See examples/README.md for status.\n\n// External C functions must be declared\nextern \"C\" func strlen(ptr: *const u8) -> i32\nextern \"C\" func memcpy(dest: *mut u8, src: *const u8, n: i32)\nextern \"C\" func malloc(size: i32) -> *mut u8\nextern \"C\" func free(ptr: *mut u8)\n\n// Wrapper for C strlen\nfunc c_string_length(s: string) -> i32 {\n    unsafe {\n        const ptr = s.as_ptr()\n        return strlen(ptr)\n    }\n}\n\n// Safe wrapper for raw pointer operations\nfunc copy_bytes(src: &Vec<u8>, dest: &Vec<u8>, count: i32) {\n    unsafe {\n        const src_ptr = src.as_ptr()\n        const dest_ptr = dest.as_mut_ptr()\n        memcpy(dest_ptr, src_ptr, count)\n    }\n}\n\n// Manual memory management (discouraged - use safe abstractions)\nfunc manual_allocation_example() {\n    print(\"\\n=== Manual Memory Allocation ===\\n\")\n\n    unsafe {\n        // Allocate 16 bytes\n        const ptr = malloc(16)\n\n        if ptr == null {\n            print(\"Allocation failed\\n\")\n            return\n        }\n\n        print(\"Allocated 16 bytes at \")\n        print(ptr as i64)\n        print(\"\\n\")\n\n        // Write some data\n        for i in 0..16 {\n            const offset_ptr = ptr.offset(i)\n            *offset_ptr = i as u8\n        }\n\n        // Read it back\n        print(\"Data: \")\n        for i in 0..16 {\n            const offset_ptr = ptr.offset(i)\n            const value = *offset_ptr\n            print(value)\n            print(\" \")\n        }\n        print(\"\\n\")\n\n        // Must free manually\n        free(ptr)\n        print(\"Memory freed\\n\")\n    }\n}\n\nfunc main() {\n    print(\"=== Unsafe Rust Interop ===\\n\")\n    print(\"Use unsafe blocks to call C functions or use raw pointers\\n\\n\")\n\n    // Call C function through safe wrapper\n    print(\"=== C FFI Example ===\\n\")\n\n    const test_str = \"Hello, C!\"\n    const len = c_string_length(test_str)\n\n    print(\"String: \")\n    print(test_str)\n    print(\"\\n\")\n\n    print(\"Length from C strlen: \")\n    print(len)\n    print(\"\\n\")\n\n    // Compare with safe method\n    print(\"Length from Rask: \")\n    print(test_str.len())\n    print(\"\\n\")\n\n    manual_allocation_example()\n\n    print(\"\\n=== Raw Pointers ===\\n\")\n\n    const numbers = Vec.from([10, 20, 30, 40, 50])\n\n    unsafe {\n        const ptr = numbers.as_ptr()\n\n        print(\"First element via pointer: \")\n        const first = *ptr\n        print(first)\n        print(\"\\n\")\n\n        print(\"Second element via offset: \")\n        const second_ptr = ptr.offset(1)\n        const second = *second_ptr\n        print(second)\n        print(\"\\n\")\n    }\n\n    print(\"\\n=== When to Use Unsafe ===\\n\")\n    print(\"1. FFI - calling C/C++ libraries\\n\")\n    print(\"2. Performance - bypassing bounds checks\\n\")\n    print(\"3. Low-level operations - memory management\\n\")\n    print(\"4. Hardware access - embedded systems\\n\")\n\n    print(\"\\n=== Safety Invariants ===\\n\")\n    print(\"YOU must ensure:\\n\")\n    print(\"- Pointers are valid and aligned\\n\")\n    print(\"- No data races on mutable access\\n\")\n    print(\"- Memory is freed exactly once\\n\")\n    print(\"- No use-after-free\\n\")\n    print(\"- Strings are valid UTF-8\\n\")\n\n    print(\"\\n=== Best Practices ===\\n\")\n    print(\"- Minimize unsafe code surface\\n\")\n    print(\"- Wrap unsafe in safe abstractions\\n\")\n    print(\"- Document safety requirements\\n\")\n    print(\"- Prefer safe Rask code when possible\\n\")\n    print(\"- Audit unsafe blocks carefully\\n\")\n\n    print(\"\\n=== Example: Safe Wrapper ===\\n\")\n    print(\"Instead of exposing raw pointers:\\n\")\n    print(\"  unsafe { ptr.offset(5) }  // Caller must ensure safety\\n\")\n    print(\"\\n\")\n    print(\"Create a safe API:\\n\")\n    print(\"  vec.get(5)  // Returns Option<T>, bounds-checked\\n\")\n    print(\"\\n\")\n    print(\"The unsafe code is contained within the implementation,\\n\")\n    print(\"and users get a safe interface.\\n\")\n}\n",
    "cli_calculator": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\nimport io\n\n// CLI Calculator - Expression Evaluator\n// Demonstrates: Parsing, enums, match expressions, error handling, REPL pattern\n\n// Token types from lexer\nenum Token {\n    Number(f64),\n    Plus,\n    Minus,\n    Star,\n    Slash,\n    Percent,\n    Caret,       // Power\n    LParen,\n    RParen,\n    Eof,\n}\n\n// AST nodes\nenum Expr {\n    Number(f64),\n    Binary(left: Owned<Expr>, op: BinaryOp, right: Owned<Expr>),\n    Unary(op: UnaryOp, expr: Owned<Expr>),\n}\n\nenum BinaryOp {\n    Add,\n    Sub,\n    Mul,\n    Div,\n    Mod,\n    Pow,\n}\n\nenum UnaryOp {\n    Neg,\n}\n\nenum CalcError {\n    UnexpectedChar(char),\n    UnexpectedToken(string),\n    DivisionByZero,\n    EmptyExpression,\n}\n\nextend CalcError {\n    func message(self) -> string {\n        match self {\n            UnexpectedChar(c) => return \"unexpected character: '{c}'\",\n            UnexpectedToken(s) => return \"unexpected token: {s}\",\n            DivisionByZero => return \"division by zero\",\n            EmptyExpression => return \"empty expression\",\n        }\n    }\n}\n\n// Lexer\nstruct Lexer {\n    input: string\n    pos: usize\n}\n\nextend Lexer {\n    func new(input: string) -> Lexer {\n        return Lexer { input: input, pos: 0 as usize }\n    }\n\n    func peek_char(self) -> char? {\n        if self.pos >= self.input.len(): return None\n        self.input.char_at(self.pos)\n    }\n\n    func advance(self) -> char? {\n        const c = try self.peek_char()\n        self.pos += 1\n        Some(c)\n    }\n\n    func skip_whitespace(self) {\n        while self.peek_char() is Some(c) {\n            if !c.is_whitespace(): break\n            self.advance()\n        }\n    }\n\n    func next_token(self) -> Token or CalcError {\n        self.skip_whitespace()\n\n        const c = match self.peek_char() {\n            Some(c) => c,\n            None => return Ok(Token.Eof),\n        }\n\n        // Single-character tokens\n        const token = match c {\n            '+' => { self.advance(); Token.Plus }\n            '-' => { self.advance(); Token.Minus }\n            '*' => { self.advance(); Token.Star }\n            '/' => { self.advance(); Token.Slash }\n            '%' => { self.advance(); Token.Percent }\n            '^' => { self.advance(); Token.Caret }\n            '(' => { self.advance(); Token.LParen }\n            ')' => { self.advance(); Token.RParen }\n            _ if c.is_digit() || c == '.' => try self.read_number(),\n            _ => return Err(CalcError.UnexpectedChar(c)),\n        }\n\n        Ok(token)\n    }\n\n    func read_number(self) -> Token or CalcError {\n        const num_str = string.new()\n        let has_dot = false\n\n        while self.peek_char() is Some(c) {\n            if c.is_digit() {\n                num_str.push(c)\n                self.advance()\n            } else if c == '.' && !has_dot {\n                has_dot = true\n                num_str.push(c)\n                self.advance()\n            } else {\n                break\n            }\n        }\n\n        const value: f64 = num_str.parse().unwrap()\n        Ok(Token.Number(value))\n    }\n}\n\n// Parser with operator precedence\nstruct Parser {\n    lexer: Lexer\n    current: Token\n}\n\nextend Parser {\n    func new(input: string) -> Parser or CalcError {\n        const lexer = Lexer.new(input)\n        const current = try lexer.next_token()\n        Ok(Parser { lexer: lexer, current: current })\n    }\n\n    func advance(self) -> () or CalcError {\n        self.current = try self.lexer.next_token()\n    }\n\n    func parse(self) -> Expr or CalcError {\n        const expr = try self.parse_expression()\n\n        match self.current {\n            Eof => return Ok(expr),\n            _ => return Err(CalcError.UnexpectedToken(self.token_string())),\n        }\n    }\n    \n\n    func token_string(self) -> string {\n        match self.current {\n            Number(n) => return \"{n}\",\n            Plus => return \"+\",\n            Minus => return \"-\",\n            Star => return \"*\",\n            Slash => return \"/\",\n            Percent => return \"%\",\n            Caret => return \"^\",\n            LParen => return \"(\",\n            RParen => return \")\",\n            Eof => return \"end of input\",\n        }\n    }\n\n    // expression = term (('+' | '-') term)*\n    func parse_expression(self) -> Expr or CalcError {\n        let left = try self.parse_term()\n\n        loop {\n            const op = match self.current {\n                Plus => BinaryOp.Add,\n                Minus => BinaryOp.Sub,\n                _ => break,\n            }\n            try self.advance()\n            const right = try self.parse_term()\n            left = Expr.Binary(left: own left, op: op, right: own right)\n        }\n\n        Ok(left)\n    }\n\n    // term = power (('*' | '/' | '%') power)*\n    func parse_term(self) -> Expr or CalcError {\n        let left = try self.parse_power()\n\n        loop {\n            const op = match self.current {\n                Star => BinaryOp.Mul,\n                Slash => BinaryOp.Div,\n                Percent => BinaryOp.Mod,\n                _ => break,\n            }\n            try self.advance()\n            const right = try self.parse_power()\n            left = Expr.Binary(left: own left, op: op, right: own right)\n        }\n\n        Ok(left)\n    }\n\n    // power = unary ('^' power)?  (right associative)\n    func parse_power(self) -> Expr or CalcError {\n        const base = try self.parse_unary()\n\n        if self.current is Caret {\n            try self.advance()\n            const exp = try self.parse_power()  // Right associative\n            return Ok(Expr.Binary(left: own base, op: BinaryOp.Pow, right: own exp))\n        } else {\n            return Ok(base)\n        }\n    }\n\n    // unary = '-' unary | primary\n    func parse_unary(self) -> Expr or CalcError {\n        if self.current is Minus {\n            try self.advance()\n            const expr = try self.parse_unary()\n            return Ok(Expr.Unary(op: UnaryOp.Neg, expr: own expr))\n        } else {\n            return self.parse_primary()\n        }\n    }\n\n    // primary = NUMBER | '(' expression ')'\n    func parse_primary(self) -> Expr or CalcError {\n        match self.current {\n            Number(n) => {\n                try self.advance()\n                return Ok(Expr.Number(n))\n            }\n            LParen => {\n                try self.advance()\n                const expr = try self.parse_expression()\n                match self.current {\n                    RParen => {\n                        try self.advance()\n                        return Ok(expr)\n                    }\n                    _ => return Err(CalcError.UnexpectedToken(\"expected ')'\".to_string())),\n                }\n            }\n            Eof => return Err(CalcError.EmptyExpression),\n            _ => return Err(CalcError.UnexpectedToken(self.token_string())),\n        }\n    }\n}\n\n// Evaluator\nfunc evaluate(expr: Expr) -> f64 or CalcError {\n    match expr {\n        Number(n) => return Ok(n),\n        Unary(op, inner) => {\n            const val = try evaluate(inner)\n            match op {\n                Neg => return Ok(-val),\n            }\n        }\n        Binary(left, op, right) => {\n            const l = try evaluate(left)\n            const r = try evaluate(right)\n            match op {\n                Add => return Ok(l + r),\n                Sub => return Ok(l - r),\n                Mul => return Ok(l * r),\n                Div => {\n                    if r == 0.0: return Err(CalcError.DivisionByZero)\n                    return Ok(l / r)\n                }\n                Mod => {\n                    if r == 0.0: return Err(CalcError.DivisionByZero)\n                    return Ok(l % r)\n                }\n                Pow => return Ok(l.powf(r)),\n            }\n        }\n    }\n}\n\nfunc calc(input: string) -> f64 or CalcError {\n    const parser = try Parser.new(input)\n    const expr = try parser.parse()\n    evaluate(expr)\n}\n\nfunc print_help() {\n    println(\"Calculator - Enter expressions to evaluate\")\n    println(\"\")\n    println(\"Operators:\")\n    println(\"  + - * /  Basic arithmetic\")\n    println(\"  %        Modulo\")\n    println(\"  ^        Power (right associative)\")\n    println(\"  ( )      Grouping\")\n    println(\"\")\n    println(\"Examples:\")\n    println(\"  2 + 3 * 4      => 14\")\n    println(\"  (2 + 3) * 4    => 20\")\n    println(\"  2 ^ 3 ^ 2      => 512 (right associative)\")\n    println(\"  -5 + 3         => -2\")\n    println(\"\")\n    println(\"Commands:\")\n    println(\"  help     Show this help\")\n    println(\"  quit     Exit calculator\")\n}\n\nfunc main() -> () or Error {\n    println(\"Rask Calculator\")\n    println(\"Type 'help' for usage, 'quit' to exit\")\n    println(\"\")\n\n    loop {\n        print(\"> \")\n        const input = (try io.read_line()).trim()\n\n        if input.is_empty(): continue\n\n        match input {\n            \"quit\" | \"exit\" | \"q\" => break,\n            \"help\" | \"h\" | \"?\" => print_help(),\n            _ => {\n                match calc(input.to_string()) {\n                    Ok(result) => println(\"= {result}\"),\n                    Err(e) => println(\"Error: {e.message()}\"),\n                }\n            }\n        }\n    }\n\n    println(\"Goodbye!\")\n}\n\n// ============================================================================\n// Tests - Demonstrates test blocks and assert statements\n// ============================================================================\n\ntest \"addition\" {\n    assert calc(\"2 + 3\") == Ok(5.0)\n    assert calc(\"10 + 20 + 30\") == Ok(60.0)\n}\n\ntest \"subtraction\" {\n    assert calc(\"10 - 3\") == Ok(7.0)\n    assert calc(\"5 - 10\") == Ok(-5.0)\n}\n\ntest \"multiplication\" {\n    assert calc(\"4 * 5\") == Ok(20.0)\n    assert calc(\"2 * 3 * 4\") == Ok(24.0)\n}\n\ntest \"division\" {\n    assert calc(\"20 / 4\") == Ok(5.0)\n    assert calc(\"7 / 2\") == Ok(3.5)\n}\n\ntest \"precedence\" {\n    // Multiplication before addition\n    assert calc(\"2 + 3 * 4\") == Ok(14.0)\n    assert calc(\"2 * 3 + 4\") == Ok(10.0)\n\n    // Division before subtraction\n    assert calc(\"10 - 6 / 2\") == Ok(7.0)\n}\n\ntest \"parentheses\" {\n    assert calc(\"(2 + 3) * 4\") == Ok(20.0)\n    assert calc(\"2 * (3 + 4)\") == Ok(14.0)\n    assert calc(\"((1 + 2) * (3 + 4))\") == Ok(21.0)\n}\n\ntest \"power right associative\" {\n    // 2^3^2 = 2^(3^2) = 2^9 = 512, not (2^3)^2 = 64\n    assert calc(\"2 ^ 3 ^ 2\") == Ok(512.0)\n    assert calc(\"2 ^ 3\") == Ok(8.0)\n}\n\ntest \"unary negation\" {\n    assert calc(\"-5\") == Ok(-5.0)\n    assert calc(\"-5 + 3\") == Ok(-2.0)\n    assert calc(\"--5\") == Ok(5.0)  // Double negation\n    assert calc(\"3 * -2\") == Ok(-6.0)\n}\n\ntest \"modulo\" {\n    assert calc(\"10 % 3\") == Ok(1.0)\n    assert calc(\"15 % 4\") == Ok(3.0)\n}\n\ntest \"floating point\" {\n    assert calc(\"3.14 * 2\") == Ok(6.28)\n    assert calc(\"1.5 + 2.5\") == Ok(4.0)\n}\n\ntest \"division by zero\" {\n    assert calc(\"5 / 0\") == Err(CalcError.DivisionByZero)\n    assert calc(\"10 % 0\") == Err(CalcError.DivisionByZero)\n}\n\ntest \"invalid input\" {\n    assert calc(\"2 +\").is_err()\n    assert calc(\"\") == Err(CalcError.EmptyExpression)\n    assert calc(\"@\").is_err()\n}\n",
    "collections_test": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Collections test - Vec, struct literals, match expressions\n// Step 9 validation\n\nstruct Point {\n    x: i32\n    y: i32\n}\n\nfunc main() {\n    // Vec basics\n    const v = Vec.new()\n    v.push(10)\n    v.push(20)\n    v.push(30)\n    const vlen = v.len()\n    println(\"Vec length: {vlen}\")\n    const v0 = v.get(0)\n    const v1 = v.get(1)\n    const v2 = v.get(2)\n    println(\"v[0] = {v0}\")\n    println(\"v[1] = {v1}\")\n    println(\"v[2] = {v2}\")\n\n    // Vec iteration\n    println(\"Iterating:\")\n    for item in v {\n        println(\"  item: {item}\")\n    }\n\n    // Array literal\n    const arr = [1, 2, 3, 4, 5]\n    const arrlen = arr.len()\n    println(\"Array length: {arrlen}\")\n\n    // Struct instantiation\n    const p = Point { x: 100, y: 200 }\n    const px = p.x\n    const py = p.y\n    println(\"Point: x={px}, y={py}\")\n\n    // Match on integers\n    const num = 2\n    const result = match num {\n        1 => \"one\",\n        2 => \"two\",\n        3 => \"three\",\n        _ => \"other\",\n    }\n    println(\"match result: {result}\")\n\n    println(\"Collections test passed!\")\n}\n",
    "file_copy": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// File Copy Utility\n// Demonstrates: CLI arg parsing, structs, enums, match, error propagation,\n//               closures (map_err), string interpolation, file I/O\n\nimport fs\nimport cli\nimport std\n\nenum CopyError {\n    SourceNotFound(string),\n    DestinationExists(string),\n    ReadError(string),\n    WriteError(string),\n    SameFile,\n}\n\nextend CopyError {\n    func message(self) -> string {\n        match self {\n            SourceNotFound(path) => return \"source file not found: {path}\",\n            DestinationExists(path) => return \"destination already exists: {path} (use -f to overwrite)\",\n            ReadError(msg) => return \"read error: {msg}\",\n            WriteError(msg) => return \"write error: {msg}\",\n            SameFile => return \"source and destination are the same file\",\n        }\n    }\n}\n\nstruct CopyOptions {\n    source: string\n    dest: string\n    force: bool\n    verbose: bool\n}\n\nfunc parse_args(args: Vec<string>) -> CopyOptions or string {\n    let opts = CopyOptions {\n        source: \"\",\n        dest: \"\",\n        force: false,\n        verbose: false,\n    }\n\n    let positional = Vec.new()\n\n    for arg in args.iter().skip(1) {\n        match arg {\n            \"-f\" | \"--force\" => opts.force = true,\n            \"-v\" | \"--verbose\" => opts.verbose = true,\n            \"-h\" | \"--help\" => {\n                print_usage()\n                std.exit(0)\n            }\n            _ => positional.push(arg.clone()),\n        }\n    }\n\n    if positional.len() < 2 {\n        return Err(\"usage: rcopy [-fv] SOURCE DEST\")\n    }\n\n    opts.source = positional[0].clone()\n    opts.dest = positional[1].clone()\n\n    return Ok(opts)\n}\n\nfunc print_usage() {\n    println(\"Usage: rcopy [OPTIONS] SOURCE DEST\")\n    println(\"\")\n    println(\"Copy SOURCE to DEST\")\n    println(\"\")\n    println(\"Options:\")\n    println(\"  -f, --force     Overwrite destination if it exists\")\n    println(\"  -v, --verbose   Show progress information\")\n    println(\"  -h, --help      Show this help\")\n}\n\nfunc copy_file(opts: CopyOptions) -> i64 or CopyError {\n    // Check source exists\n    if !fs.exists(opts.source.clone()) {\n        return Err(CopyError.SourceNotFound(opts.source))\n    }\n\n    // Check destination\n    if fs.exists(opts.dest.clone()) {\n        if !opts.force {\n            return Err(CopyError.DestinationExists(opts.dest))\n        }\n    }\n\n    // Check not same file (using canonical paths)\n    const src_canonical = try fs.canonicalize(opts.source.clone())\n        .map_err(|e| CopyError.ReadError(e))\n    const dst_canonical = fs.canonicalize(opts.dest.clone()).ok()\n\n    if dst_canonical is Some(dst) {\n        if src_canonical == dst {\n            return Err(CopyError.SameFile)\n        }\n    }\n\n    // Copy the file\n    const bytes = try fs.copy(opts.source.clone(), opts.dest.clone())\n        .map_err(|e| CopyError.WriteError(e))\n\n    return Ok(bytes)\n}\n\nfunc format_size(bytes: i64) -> string {\n    if bytes < 1024 {\n        return \"{bytes} B\"\n    } else if bytes < 1048576 {\n        const kb = bytes / 1024\n        return \"{kb} KB\"\n    } else {\n        const mb = bytes / 1048576\n        return \"{mb} MB\"\n    }\n}\n\nfunc main() {\n    const args = cli.args()\n\n    const opts = match parse_args(args) {\n        Ok(o) => o,\n        Err(msg) => {\n            println(\"rcopy: {msg}\")\n            std.exit(1)\n        }\n    }\n\n    if opts.verbose {\n        println(\"Copying '{opts.source}' to '{opts.dest}'...\")\n    }\n\n    match copy_file(opts.clone()) {\n        Ok(bytes) => {\n            if opts.verbose {\n                const size = format_size(bytes)\n                println(\"Copied {size}\")\n            }\n        }\n        Err(e) => {\n            const msg = e.message()\n            println(\"rcopy: {msg}\")\n            std.exit(1)\n        }\n    }\n}\n",
    "game_loop": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Game Loop with Entities\n// Demonstrates: Pool pattern, handle-based refs, traits, threading, time/delta, game systems\n\nimport time\nimport random\n\n// Trait for updatable components\ntrait Updatable {\n    func update(self, dt: f32)\n}\n\n// Position implements Updatable (applies velocity)\nextend Position with Updatable {\n    func update(self, dt: f32) {\n        // Position updated by movement system\n    }\n}\n\n// Component types\nstruct Position {\n    x: f32\n    y: f32\n}\n\nstruct Velocity {\n    dx: f32\n    dy: f32\n}\n\nstruct Health {\n    current: i32\n    max: i32\n}\n\nstruct Collider {\n    radius: f32\n}\n\n// Entity with all components\nstruct Entity {\n    position: Position\n    velocity: Velocity\n    health: Health\n    collider: Collider\n    active: bool\n    entity_type: EntityType\n}\n\nenum EntityType {\n    Player,\n    Enemy,\n    Projectile,\n}\n\n// Game state\nstruct GameState {\n    entities: Pool<Entity>\n    player: Handle<Entity>?\n    score: i32\n    game_over: bool\n}\n\nextend GameState {\n    func new() -> GameState or Error {\n        let entities = Pool.new()\n\n        // Spawn player at center\n        const player_handle = try entities.insert(Entity {\n            position: Position { x: 400.0f32, y: 300.0f32 },\n            velocity: Velocity { dx: 0.0f32, dy: 0.0f32 },\n            health: Health { current: 100, max: 100 },\n            collider: Collider { radius: 16.0f32 },\n            active: true,\n            entity_type: EntityType.Player,\n        })\n\n        return Ok(GameState {\n            entities: entities,\n            player: Some(player_handle),\n            score: 0,\n            game_over: false,\n        })\n    }\n\n    func spawn_enemy(self, x: f32, y: f32) -> Handle<Entity> or Error {\n        return self.entities.insert(Entity {\n            position: Position { x: x, y: y },\n            velocity: Velocity { dx: -50.0f32, dy: 0.0f32 },\n            health: Health { current: 20, max: 20 },\n            collider: Collider { radius: 12.0f32 },\n            active: true,\n            entity_type: EntityType.Enemy,\n        })\n    }\n\n    func spawn_projectile(self, x: f32, y: f32, dx: f32, dy: f32) -> Handle<Entity> or Error {\n        return self.entities.insert(Entity {\n            position: Position { x: x, y: y },\n            velocity: Velocity { dx: dx, dy: dy },\n            health: Health { current: 1, max: 1 },\n            collider: Collider { radius: 4.0f32 },\n            active: true,\n            entity_type: EntityType.Projectile,\n        })\n    }\n}\n\n// System: Update positions based on velocities\n// here we only use the entities pool from GameState, so we can use a projection\n// This allows us to avoid borrowing the entire GameState\nfunc movement_system(entities: GameState.{entities}, dt: f32) {\n    for h in entities {\n        if !entities[h].active: continue\n\n        entities[h].position.x += entities[h].velocity.dx * dt\n        entities[h].position.y += entities[h].velocity.dy * dt\n    }\n}\n\n// System: Check collisions between entities\nfunc collision_system(state: GameState) {\n    let to_check = state.entities.handles()\n\n    for i in 0..to_check.len() {\n        for j in (i + 1)..to_check.len() {\n            const h1 = to_check[i]\n            const h2 = to_check[j]\n\n            if !state.entities[h1].active || !state.entities[h2].active: continue\n\n            const e1 = state.entities[h1]\n            const e2 = state.entities[h2]\n\n            // Calculate distance\n            const dx = e1.position.x - e2.position.x\n            const dy = e1.position.y - e2.position.y\n            const dist = (dx * dx + dy * dy).sqrt()\n            const min_dist = e1.collider.radius + e2.collider.radius\n\n            if dist < min_dist {\n                handle_collision(state, h1, h2)\n            }\n        }\n    }\n}\n\nfunc handle_collision(state: GameState, h1: Handle<Entity>, h2: Handle<Entity>) {\n    const type1 = state.entities[h1].entity_type\n    const type2 = state.entities[h2].entity_type\n\n    // Player vs Enemy\n    if (type1 == EntityType.Player && type2 == EntityType.Enemy) ||\n       (type1 == EntityType.Enemy && type2 == EntityType.Player) {\n        const player_h = if type1 == EntityType.Player: h1 else: h2\n        const enemy_h = if type1 == EntityType.Enemy: h1 else: h2\n\n        state.entities[player_h].health.current -= 10\n        state.entities[enemy_h].active = false\n\n        if state.entities[player_h].health.current <= 0 {\n            state.game_over = true\n        }\n    }\n\n    // Projectile vs Enemy\n    if (type1 == EntityType.Projectile && type2 == EntityType.Enemy) ||\n       (type1 == EntityType.Enemy && type2 == EntityType.Projectile) {\n        const enemy_h = if type1 == EntityType.Enemy: h1 else: h2\n        const proj_h = if type1 == EntityType.Projectile: h1 else: h2\n\n        state.entities[enemy_h].health.current -= 25\n        state.entities[proj_h].active = false\n\n        if state.entities[enemy_h].health.current <= 0 {\n            state.entities[enemy_h].active = false\n            state.score += 100\n        }\n    }\n}\n\n// System: Remove inactive entities\nfunc cleanup_system(state: GameState) {\n    let to_remove = Vec.new()\n\n    for h in state.entities {\n        if !state.entities[h].active {\n            to_remove.push(h).ok()\n        }\n    }\n\n    for h in to_remove {\n        state.entities.remove(h)\n    }\n}\n\n// System: Spawn enemies periodically\nfunc spawn_system(state: GameState, time_since_last_spawn: f32) -> f32 {\n    const spawn_interval = 2.0f32\n\n    if time_since_last_spawn >= spawn_interval {\n        // Spawn enemy at right edge with random y\n        const y = (random.f32() * 500.0f32) + 50.0f32\n        state.spawn_enemy(850.0f32, y).ok()\n        return 0.0f32  // Reset timer\n    } else {\n        return time_since_last_spawn\n    }\n}\n\n// Parallel movement update - processes entity batches across threads\nfunc parallel_movement_system(entities: GameState.{entities}, dt: f32, num_threads: usize) {\n    let handles = entities.handles()\n    let chunk_size = (handles.len() + num_threads - 1) / num_threads\n\n    // Split work across thread pool\n    let thread_handles = Vec.new()\n    for chunk in handles.chunks(chunk_size) {\n        let chunk = chunk.to_vec()\n        let task = spawn_thread {\n            for h in chunk {\n                if !entities[h].active: continue\n                entities[h].position.x += entities[h].velocity.dx * dt\n                entities[h].position.y += entities[h].velocity.dy * dt\n            }\n        }\n        thread_handles.push(task).ok()\n    }\n\n    // Wait for all chunks to complete\n    for h in thread_handles {\n        h.join().ok()\n    }\n}\n\n// Main game loop with fixed timestep and threading\nfunc main() -> () or Error {\n    // Thread pool for CPU-bound physics work\n    with threading(4) {\n        let state = try GameState.new()\n\n        const target_fps = 60.0f32\n        const dt = 1.0f32 / target_fps\n        const NUM_PHYSICS_THREADS: usize = 4u64\n\n        let last_time = 0.0f32  // Simplified: track elapsed time\n        let accumulator = 0.0f32\n        let spawn_timer = 0.0f32\n        let frame_count = 0\n\n        println(\"Game started! Score: 0\")\n\n        // Simulate game for a few seconds\n        while !state.game_over && frame_count < 300 {\n            // Simulate frame time (16ms = ~60fps)\n            const frame_time = 0.016f32\n            last_time += frame_time\n\n            accumulator += frame_time\n\n            // Fixed timestep updates\n            while accumulator >= dt {\n                // Handle input (simulated - would be real input in actual game)\n                if frame_count % 30 == 0 {\n                    // Fire projectile\n                    if state.player is Some(player_h) {\n                        const px = state.entities[player_h].position.x\n                        const py = state.entities[player_h].position.y\n                        try state.spawn_projectile(px + 20.0f32, py, 300.0f32, 0.0f32)\n                    }\n                }\n\n                // Parallel physics: split entity updates across thread pool\n                // Each thread processes a batch of entities\n                parallel_movement_system(state, dt, NUM_PHYSICS_THREADS)\n\n                // Collision runs single-threaded (needs to see all entities)\n                collision_system(state)\n\n                // Game logic on main thread\n                spawn_timer = spawn_system(state, spawn_timer + dt)\n                cleanup_system(state)\n\n                accumulator -= dt\n            }\n\n            // Render (simulated - just print status occasionally)\n            if frame_count % 60 == 0 {\n                const entity_count = state.entities.len()\n                let player_health = 0\n                if state.player is Some(h) {\n                    player_health = state.entities[h].health.current\n                }\n                println(\"Frame {frame_count}: Entities={entity_count}, Health={player_health}, Score={state.score}\")\n            }\n\n            frame_count += 1\n\n            // In a real game, we'd sleep here to maintain frame rate\n            // time.sleep(time.Duration.from_millis(16))\n        }\n\n        if state.game_over {\n            println(\"Game Over! Final Score: {state.score}\")\n        } else {\n            println(\"Demo complete! Final Score: {state.score}\")\n        }\n    }\n\n    return Result.Ok(())\n}\n",
    "grep_clone": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// grep clone - Pattern Search CLI Tool\n// Demonstrates: CLI args, file I/O, string operations, iteration, error handling\n\nimport fs\nimport cli\nimport std\n\nstruct Options {\n    pattern: string\n    files: Vec<string>\n    ignore_case: bool\n    line_numbers: bool\n    count_only: bool\n    invert_match: bool\n}\n\nenum GrepError {\n    NoPattern,\n    NoFiles,\n    FileError(string),\n}\n\nextend GrepError {\n    func message(self) -> string {\n        match self {\n            NoPattern => return \"missing pattern argument\",\n            NoFiles => return \"no files specified\",\n            FileError(msg) => return \"{msg}\",\n        }\n    }\n}\n\nfunc parse_args(args: Vec<string>) -> Options or GrepError {\n    let opts = Options {\n        pattern: \"\",\n        files: Vec.new(),\n        ignore_case: false,\n        line_numbers: false,\n        count_only: false,\n        invert_match: false,\n    }\n\n    let positional = Vec.new()\n\n    for arg in args.iter().skip(1) {\n        match arg {\n            \"-i\" => opts.ignore_case = true,\n            \"-n\" => opts.line_numbers = true,\n            \"-c\" => opts.count_only = true,\n            \"-v\" => opts.invert_match = true,\n            \"-h\" | \"--help\" => {\n                print_usage()\n                std.exit(0)\n            }\n            \"--\" => {}  // Skip arg delimiter\n            _ => positional.push(arg.clone()),\n        }\n    }\n\n    if positional.len() == 0: return Err(GrepError.NoPattern)\n    opts.pattern = positional[0].clone()\n\n    // Collect remaining positional args as files\n    if positional.len() == 1: return Err(GrepError.NoFiles)\n    let i = 1\n    while i < positional.len() {\n        opts.files.push(positional[i].clone())\n        i = i + 1\n    }\n\n    return Ok(opts)\n}\n\nfunc print_usage() {\n    println(\"Usage: rgrep [OPTIONS] PATTERN FILE...\")\n    println(\"\")\n    println(\"Options:\")\n    println(\"  -i    Ignore case\")\n    println(\"  -n    Show line numbers\")\n    println(\"  -c    Count matching lines only\")\n    println(\"  -v    Invert match (show non-matching lines)\")\n    println(\"  -h    Show this help\")\n}\n\nfunc line_matches(line: string, pattern: string, ignore_case: bool) -> bool {\n    if ignore_case {\n        const lower_line = line.to_lowercase()\n        const lower_pattern = pattern.to_lowercase()\n        return lower_line.contains(lower_pattern)\n    } else {\n        return line.contains(pattern)\n    }\n}\n\nfunc grep_file(path: string, opts: Options) -> i64 or GrepError {\n    const content = try fs.read_file(path.clone())\n        .map_err(|e| GrepError.FileError(e))\n\n    const lines = content.lines()\n    let match_count: i64 = 0\n    let line_num = 0\n\n    for line in lines {\n        line_num = line_num + 1\n        const matches = line_matches(line.clone(), opts.pattern.clone(), opts.ignore_case)\n        const show = if opts.invert_match: !matches else: matches\n\n        if show {\n            match_count = match_count + 1\n\n            if !opts.count_only {\n                if opts.line_numbers {\n                    println(\"{line_num}:{line}\")\n                } else {\n                    println(\"{line}\")\n                }\n            }\n        }\n    }\n\n    if opts.count_only {\n        println(\"{match_count}\")\n    }\n\n    return Ok(match_count)\n}\n\nfunc main() {\n    const args = cli.args()\n    const opts = match parse_args(args) {\n        Ok(o) => o,\n        Err(e) => {\n            const msg = e.message()\n            println(\"rgrep: {msg}\")\n            print_usage()\n            std.exit(1)\n        }\n    }\n\n    let total_matches = 0\n    let had_errors = false\n\n    for file_path in opts.files.clone() {\n        match grep_file(file_path, opts.clone()) {\n            Ok(count) => total_matches = total_matches + count,\n            Err(e) => {\n                const msg = e.message()\n                println(\"rgrep: {msg}\")\n                had_errors = true\n            }\n        }\n    }\n\n    if had_errors: std.exit(2)\n    if total_matches == 0: std.exit(1)\n}\n",
    "hello_world": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\nfunc main() {\n    println(\"Hello, World!\")\n}\n",
    "http_api_server": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// HTTP JSON API Server\n// Demonstrates: Concurrency (spawn, channels), JSON, error handling, with multitasking\n\nimport net\nimport json\nimport time\n\n// User data stored in memory\nstruct User {\n    public id: i64\n    public name: string\n    public email: string\n}\n\n// API request/response types\nstruct CreateUserRequest {\n    name: string\n    email: string\n}\n\nstruct UserResponse {\n    id: i64\n    name: string\n    email: string\n}\n\nstruct ErrorResponse {\n    error: string\n}\n\n// Log entry for request logging via channel\nstruct LogEntry {\n    timestamp: time.Instant\n    method: string\n    path: string\n    status: i32\n    duration_ms: f64\n}\n\n// Simple in-memory database using Shared for concurrent access\nstruct Database {\n    users: Map<i64, User>\n    next_id: i64\n}\n\nextend Database {\n    func new() -> Database {\n        Database {\n            users: Map.new(),\n            next_id: 1,\n        }\n    }\n}\n\n// Handle a single HTTP request with logging\nfunc handle_request(\n    conn: TcpConnection,\n    db: Shared<Database>,\n    log_tx: Sender<LogEntry>\n) -> () or Error {\n    const start = time.Instant.now()\n    const request = try conn.read_http_request()\n\n    const response = match (request.method, request.path) {\n        (\"GET\", \"/users\") => list_users(db),\n        (\"GET\", path) if path.starts_with(\"/users/\") => {\n            const id = try path[7..].parse<i64>()\n            get_user(db, id)\n        }\n        (\"POST\", \"/users\") => create_user(db, request.body),\n        (\"DELETE\", path) if path.starts_with(\"/users/\") => {\n            const id = try path[7..].parse<i64>()\n            delete_user(db, id)\n        }\n        _ => http_response(404, json.encode(ErrorResponse { error: \"Not found\" })),\n    }\n\n    try conn.write_http_response(response)\n\n    // Send log entry through channel (non-blocking with buffered channel)\n    try log_tx.send(LogEntry {\n        timestamp: start,\n        method: request.method,\n        path: request.path,\n        status: response.status,\n        duration_ms: start.elapsed().as_secs_f64() * 1000.0,\n    })\n\n    Ok(())\n}\n\nfunc list_users(db: Shared<Database>) -> HttpResponse {\n    const users = db.read(|d| {\n        d.users.values().map(|u| UserResponse {\n            id: u.id,\n            name: u.name.clone(),\n            email: u.email.clone(),\n        }).collect()\n    })\n    http_response(200, json.encode(users))\n}\n\nfunc get_user(db: Shared<Database>, id: i64) -> HttpResponse {\n    const user = db.read(|d| d.users.get(id).map(|u| UserResponse {\n        id: u.id,\n        name: u.name.clone(),\n        email: u.email.clone(),\n    }))\n\n    match user {\n        Some(u) => http_response(200, json.encode(u)),\n        None => http_response(404, json.encode(ErrorResponse { error: \"User not found\" })),\n    }\n}\n\nfunc create_user(db: Shared<Database>, body: string) -> HttpResponse {\n    const req = match json.decode<CreateUserRequest>(body) {\n        Ok(r) => r,\n        Err(e) => return http_response(400, json.encode(ErrorResponse {\n            error: \"Invalid JSON: {e}\"\n        })),\n    }\n\n    const user = db.write(|d| {\n        const id = d.next_id\n        d.next_id += 1\n        const user = User { id: id, name: req.name, email: req.email }\n        try d.users.insert(id, user.clone())\n        UserResponse { id: user.id, name: user.name, email: user.email }\n    })\n\n    http_response(201, json.encode(user))\n}\n\nfunc delete_user(db: Shared<Database>, id: i64) -> HttpResponse {\n    const removed = db.write(|d| d.users.remove(id))\n\n    match removed {\n        Some(_) => http_response(204, \"\"),\n        None => http_response(404, json.encode(ErrorResponse { error: \"User not found\" })),\n    }\n}\n\nfunc http_response(status: i32, body: string) -> HttpResponse {\n    HttpResponse {\n        status: status,\n        headers: Map.from([(\"Content-Type\", \"application/json\")]),\n        body: body,\n    }\n}\n\nfunc main() -> () or Error {\n    const db = Shared.new(Database.new())\n\n    // Create buffered channel for request logging\n    let (log_tx, log_rx) = Channel<LogEntry>.buffered(100)\n\n    with multitasking {\n        // Spawn logger task that consumes log entries\n        spawn {\n            while log_rx.recv() is Ok(entry) {\n                const elapsed = entry.timestamp.elapsed().as_secs_f64()\n                println(\"[{elapsed:.3}s] {entry.method} {entry.path} -> {entry.status} ({entry.duration_ms:.2}ms)\")\n            }\n        }.detach()\n\n        const listener = try net.tcp_listen(\"0.0.0.0:8080\")\n        println(\"Server listening on :8080\")\n\n        loop {\n            const conn = try listener.accept()\n            const db_ref = db.clone()\n            const log_tx_ref = log_tx.clone()\n\n            // Spawn a green task for each connection\n            spawn {\n                match handle_request(conn, db_ref, log_tx_ref) {\n                    Ok(()) => {}\n                    Err(e) => println(\"Request error: {e}\"),\n                }\n            }.detach()\n        }\n    }\n}\n",
    "pool_test": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\nstruct Entity {\n    name: string\n    health: i32\n    active: bool\n}\n\nfunc main() -> () or string {\n    // Basic pool operations\n    const pool = Pool.new()\n\n    const h1 = try pool.insert(Entity { name: \"Alice\", health: 100, active: true })\n    const h2 = try pool.insert(Entity { name: \"Bob\", health: 80, active: true })\n    const h3 = try pool.insert(Entity { name: \"Charlie\", health: 60, active: true })\n\n    const len = pool.len()\n    println(\"Pool length: {len}\")\n    const is_empty = pool.is_empty()\n    println(\"Is empty: {is_empty}\")\n\n    // Index access - read whole value\n    const e1 = pool[h1]\n    println(\"Entity 1: {e1.name}\")\n\n    // Index access - read field\n    const name2 = pool[h2].name\n    const health2 = pool[h2].health\n    println(\"Entity 2: {name2}, health={health2}\")\n\n    // Field assignment via index\n    pool[h1].health = 90\n    const h1_health = pool[h1].health\n    println(\"After assignment: h1 health={h1_health}\")\n\n    // Compound assignment (pool[h].field -= value)\n    pool[h2].health -= 20\n    const h2_health = pool[h2].health\n    println(\"After compound assign: h2 health={h2_health}\")\n\n    // Contains check\n    const c1 = pool.contains(h1)\n    const c3 = pool.contains(h3)\n    println(\"Contains h1: {c1}\")\n    println(\"Contains h3: {c3}\")\n\n    // Remove\n    pool.remove(h3)\n    const len2 = pool.len()\n    println(\"Pool length after remove: {len2}\")\n    const c3_after = pool.contains(h3)\n    println(\"Contains h3 after remove: {c3_after}\")\n\n    // Safe get on valid handle\n    const maybe = pool.get(h1)\n    if maybe is Some(entity) {\n        println(\"Got h1: {entity.name}\")\n    }\n\n    // Safe get on stale handle (should be None)\n    const stale = pool.get(h3)\n    if stale is None {\n        println(\"Correctly got None for stale handle\")\n    }\n\n    // Iteration via cursor\n    println(\"All entities via cursor:\")\n    for h in pool.cursor() {\n        const e = pool[h]\n        println(\"  {e.name}: health={e.health}\")\n    }\n\n    // Insert more entities to test slot reuse\n    const h4 = try pool.insert(Entity { name: \"Diana\", health: 70, active: true })\n    const len3 = pool.len()\n    println(\"After inserting Diana, pool length: {len3}\")\n\n    // Safe removal during iteration\n    pool[h4].health = 30\n    for h in pool.cursor() {\n        const e = pool[h]\n        if e.health < 50 {\n            pool.remove(h)\n        }\n    }\n    const len4 = pool.len()\n    println(\"Pool length after cleanup: {len4}\")\n\n    // Verify remaining entities\n    println(\"Remaining entities:\")\n    for h in pool.cursor() {\n        const e = pool[h]\n        println(\"  {e.name}: health={e.health}\")\n    }\n\n    println(\"Pool test passed!\")\n    Ok(())\n}\n",
    "sensor_processor": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Embedded Sensor Processor\n// Demonstrates: Lock-free atomics, unsafe hardware access, hard real-time deadlines,\n//               zero-allocation hot paths, interrupt handling, generics, SIMD\n\nimport time\n\n// ============================================================================\n// Lock-free SPSC (Single Producer Single Consumer) Ring Buffer\n// Used for interrupt handler â†’ main loop communication without locks\n// ============================================================================\n\nstruct SpscRingBuffer<T, const N: usize> {\n    data: [T; N]\n    write_idx: Atomic<usize>  // Written by producer (interrupt)\n    read_idx: Atomic<usize>   // Written by consumer (main loop)\n}\n\nextend SpscRingBuffer<T, N> {\n    func new(default: T) -> SpscRingBuffer<T, N> {\n        SpscRingBuffer {\n            data: [default; N],\n            write_idx: Atomic.new(0),\n            read_idx: Atomic.new(0),\n        }\n    }\n\n    // Called from interrupt context - must be lock-free and allocation-free\n    @no_alloc\n    func try_push(self, value: T) -> bool {\n        const write = self.write_idx.load(Ordering.Relaxed)\n        const next_write = (write + 1) % N\n\n        // Check if full (would overwrite unread data)\n        if next_write == self.read_idx.load(Ordering.Acquire) {\n            return false  // Buffer full, drop sample\n        }\n\n        self.data[write] = value\n        self.write_idx.store(next_write, Ordering.Release)\n        true\n    }\n\n    // Called from main loop - allocation-free for real-time safety\n    @no_alloc\n    func try_pop(self) -> T? {\n        const read = self.read_idx.load(Ordering.Relaxed)\n        const write = self.write_idx.load(Ordering.Acquire)\n\n        if read == write {\n            return None  // Buffer empty\n        }\n\n        const value = self.data[read]\n        self.read_idx.store((read + 1) % N, Ordering.Release)\n        Some(value)\n    }\n\n    func len(self) -> usize {\n        const write = self.write_idx.load(Ordering.Acquire)\n        const read = self.read_idx.load(Ordering.Acquire)\n        if write >= read { write - read } else { N - read + write }\n    }\n}\n\n// ============================================================================\n// Sensor Reading with Timestamp (for latency measurement)\n// ============================================================================\n\nstruct SensorReading {\n    sensor_id: u8\n    value: f32\n    timestamp_ns: u64  // Nanoseconds since start\n}\n\n// ============================================================================\n// Simulated Hardware Registers (demonstrates unsafe)\n// In real embedded, these would be memory-mapped I/O addresses\n// ============================================================================\n\nconst SENSOR_BASE_ADDR: usize = 0x4000_0000\n\n// ============================================================================\n// Compile-Time Lookup Tables (demonstrates comptime)\n// Generated at compile time, embedded in binary - zero runtime cost\n// ============================================================================\n\n// CRC-8 lookup table for packet validation (polynomial 0x07)\ncomptime func build_crc8_table() -> [u8; 256] {\n    const table = [0u8; 256]\n    for i in 0..256 {\n        let crc = i as u8\n        for _ in 0..8 {\n            if crc & 0x80 != 0 {\n                crc = (crc << 1) ^ 0x07\n            } else {\n                crc = crc << 1\n            }\n        }\n        table[i] = crc\n    }\n    table\n}\n\nconst CRC8_TABLE: [u8; 256] = comptime build_crc8_table()\n\n// ADC value to temperature conversion (10-bit ADC, -40Â°C to +125Â°C range)\n// Pre-computed to avoid floating point in interrupt context\ncomptime func build_temp_calibration() -> [i16; 1024] {\n    const table = [0i16; 1024]\n    for adc in 0..1024 {\n        // Linear mapping: ADC 0 = -40.00Â°C, ADC 1023 = +125.00Â°C\n        // Stored as centidegrees (Ã—100) for integer math\n        const temp_centidegrees = -4000 + (adc * 16500) / 1023\n        table[adc] = temp_centidegrees as i16\n    }\n    table\n}\n\nconst TEMP_CALIBRATION: [i16; 1024] = comptime build_temp_calibration()\n\n// Sensor command opcodes - compile-time map for protocol parsing\ncomptime func build_command_table() -> [u8; 256] {\n    // Maps ASCII command bytes to opcode constants\n    // 0 = invalid, 1 = read, 2 = write, 3 = reset, 4 = calibrate\n    const table = [0u8; 256]\n    table['R' as usize] = 1  // Read\n    table['r' as usize] = 1\n    table['W' as usize] = 2  // Write\n    table['w' as usize] = 2\n    table['X' as usize] = 3  // Reset\n    table['x' as usize] = 3\n    table['C' as usize] = 4  // Calibrate\n    table['c' as usize] = 4\n    table\n}\n\nconst COMMAND_OPCODES: [u8; 256] = comptime build_command_table()\n\n// CRC-8 computation using pre-computed table - runs in interrupt context\n@inline @no_alloc\nfunc crc8(data: []u8) -> u8 {\n    let crc = 0u8\n    for byte in data {\n        crc = CRC8_TABLE[(crc ^ byte) as usize]\n    }\n    crc\n}\n\n// Convert raw ADC reading to temperature (centidegrees) - no FP, O(1)\n@inline @no_alloc\nfunc adc_to_temp(adc_value: u16) -> i16 {\n    TEMP_CALIBRATION[adc_value.min(1023) as usize]\n}\n\n// Parse command byte to opcode - O(1) lookup\n@inline @no_alloc\nfunc parse_command(cmd: u8) -> u8 {\n    COMMAND_OPCODES[cmd as usize]\n}\n\nstruct HardwareRegisters {\n    temp_data: u32      // offset 0x00\n    pressure_data: u32  // offset 0x04\n    humidity_data: u32  // offset 0x08\n    status: u32         // offset 0x0C\n    control: u32        // offset 0x10\n}\n\n// Read from simulated hardware register\nfunc read_hardware_sensor(sensor_id: u8, tick: u64) -> f32 {\n    // In real embedded code, this would be:\n    // unsafe {\n    //     const regs = SENSOR_BASE_ADDR as *const HardwareRegisters\n    //     match sensor_id {\n    //         0 => (*regs).temp_data as f32 / 100.0,\n    //         1 => (*regs).pressure_data as f32 / 10.0,\n    //         2 => (*regs).humidity_data as f32 / 100.0,\n    //         _ => 0.0,\n    //     }\n    // }\n\n    // Simulated sensor values with realistic noise\n    const base = match sensor_id {\n        0 => 2200,   // Temperature: 22.00Â°C base\n        1 => 10130,  // Pressure: 1013.0 hPa base\n        2 => 4500,   // Humidity: 45.00% base\n        _ => 0,\n    }\n\n    // Deterministic \"noise\" based on tick (simulates ADC noise)\n    const noise = ((tick * 7 + sensor_id as u64 * 13) % 100) as i32 - 50\n    (base + noise) as f32 / 100.0\n}\n\n// ============================================================================\n// Timing Statistics with Jitter Analysis\n// ============================================================================\n\nstruct TimingStats {\n    samples: [u64; 256]     // Fixed buffer for cycle times\n    sample_idx: usize\n    sample_count: usize\n    min_ns: u64\n    max_ns: u64\n    sum_ns: u64\n    sum_squared_ns: u128    // For variance calculation\n    deadline_misses: u64\n}\n\nextend TimingStats {\n    func new() -> TimingStats {\n        TimingStats {\n            samples: [0u64; 256],\n            sample_idx: 0,\n            sample_count: 0,\n            min_ns: u64.MAX,\n            max_ns: 0,\n            sum_ns: 0,\n            sum_squared_ns: 0,\n            deadline_misses: 0,\n        }\n    }\n\n    // Record a cycle time - O(1), no allocation\n    @no_alloc\n    func record(self, cycle_ns: u64, deadline_ns: u64) {\n        // Update rolling buffer\n        self.samples[self.sample_idx] = cycle_ns\n        self.sample_idx = (self.sample_idx + 1) % 256\n\n        // Update statistics\n        if self.sample_count < 256 {\n            self.sample_count += 1\n        }\n        if cycle_ns < self.min_ns: self.min_ns = cycle_ns\n        if cycle_ns > self.max_ns: self.max_ns = cycle_ns\n        self.sum_ns += cycle_ns\n        self.sum_squared_ns += (cycle_ns as u128) * (cycle_ns as u128)\n\n        if cycle_ns > deadline_ns {\n            self.deadline_misses += 1\n        }\n    }\n\n    func mean_ns(self) -> u64 {\n        if self.sample_count == 0: return 0\n        self.sum_ns / self.sample_count as u64\n    }\n\n    // Jitter = standard deviation of cycle times\n    func jitter_ns(self) -> u64 {\n        if self.sample_count < 2: return 0\n        const n = self.sample_count as u128\n        const mean = self.sum_ns as u128 / n\n        const variance = (self.sum_squared_ns / n) - (mean * mean)\n        // Integer sqrt approximation\n        isqrt(variance) as u64\n    }\n}\n\n// Integer square root (no floating point in hot path)\n@no_alloc\nfunc isqrt(n: u128) -> u128 {\n    if n == 0: return 0\n    let x = n\n    let y = (x + 1) / 2\n    while y < x {\n        x = y\n        y = (x + n / x) / 2\n    }\n    x\n}\n\n// ============================================================================\n// Interrupt Handler Simulation (runs on separate thread)\n// ============================================================================\n\n@no_alloc\nfunc interrupt_handler(\n    buffer: SpscRingBuffer<SensorReading, 256>,\n    start_time: time.Instant,\n    running: Atomic<bool>,\n    sample_rate_hz: u32\n) {\n    const period_ns = 1_000_000_000u64 / sample_rate_hz as u64\n    let next_sample_time = start_time\n    let sequence: u64 = 0\n\n    while running.load(Ordering.Relaxed) {\n        // Spin-wait until sample time (simulates hardware timer interrupt)\n        while time.Instant.now().duration_since(start_time).as_nanos() <\n              next_sample_time.duration_since(start_time).as_nanos() {\n            // Spin - in real embedded this would be WFI (wait for interrupt)\n            core.hint.spin_loop()\n        }\n\n        const now_ns = time.Instant.now().duration_since(start_time).as_nanos()\n\n        // Read all sensors and push to lock-free buffer\n        for sensor_id in 0u8..3u8 {\n            const reading = SensorReading {\n                sensor_id: sensor_id,\n                value: read_hardware_sensor(sensor_id, sequence),\n                timestamp_ns: now_ns,\n            }\n\n            if !buffer.try_push(reading) {\n                // Buffer overflow - in real system would set error flag\n                // Cannot print here (interrupt context)\n            }\n        }\n\n        sequence += 1\n        next_sample_time = start_time + time.Duration.from_nanos(period_ns * sequence)\n    }\n}\n\n// ============================================================================\n// Main Processing Loop\n// ============================================================================\n\nstruct ProcessorState {\n    // Circular buffers for each sensor (no allocation after init)\n    temp_history: [f32; 64]\n    pressure_history: [f32; 64]\n    humidity_history: [f32; 64]\n    history_idx: usize\n    history_count: usize\n\n    // Processed outputs\n    temp_avg: f32\n    pressure_avg: f32\n    humidity_avg: f32\n\n    // Counters\n    samples_processed: u64\n    buffer_overflows: u64\n}\n\nextend ProcessorState {\n    func new() -> ProcessorState {\n        ProcessorState {\n            temp_history: [0.0f32; 64],\n            pressure_history: [0.0f32; 64],\n            humidity_history: [0.0f32; 64],\n            history_idx: 0,\n            history_count: 0,\n            temp_avg: 0.0,\n            pressure_avg: 0.0,\n            humidity_avg: 0.0,\n            samples_processed: 0,\n            buffer_overflows: 0,\n        }\n    }\n\n    // Process a single reading - must complete in bounded time\n    @inline @no_alloc\n    func process_reading(self, reading: SensorReading) {\n        // Store in appropriate history buffer\n        match reading.sensor_id {\n            0 => self.temp_history[self.history_idx] = reading.value,\n            1 => self.pressure_history[self.history_idx] = reading.value,\n            2 => self.humidity_history[self.history_idx] = reading.value,\n            _ => {}\n        }\n\n        // Update index only after all sensors for this tick\n        if reading.sensor_id == 2 {\n            self.history_idx = (self.history_idx + 1) % 64\n            if self.history_count < 64 {\n                self.history_count += 1\n            }\n        }\n\n        self.samples_processed += 1\n    }\n\n    // Compute averages using SIMD for vectorized summation\n    // 64-element arrays = 8 iterations of f32x8 (256-bit SIMD)\n    @no_alloc\n    func compute_averages(self) {\n        if self.history_count == 0: return\n\n        // Use SIMD to sum arrays in parallel\n        // Process 8 floats at a time using f32x8 (AVX on x86, NEON on ARM)\n        const temp_sum = simd_sum_f32(self.temp_history, self.history_count)\n        const pressure_sum = simd_sum_f32(self.pressure_history, self.history_count)\n        const humidity_sum = simd_sum_f32(self.humidity_history, self.history_count)\n\n        const n = self.history_count as f32\n        self.temp_avg = temp_sum / n\n        self.pressure_avg = pressure_sum / n\n        self.humidity_avg = humidity_sum / n\n    }\n}\n\n// SIMD-optimized array sum using 8-wide vectors\n// Processes 8 f32 values per iteration (AVX-256 / NEON)\n@no_alloc @inline\nfunc simd_sum_f32(data: [f32; 64], count: usize) -> f32 {\n    // Accumulator vector - 8 parallel sums\n    let acc: f32x8 = [0.0; 8]\n\n    // Process full 8-element chunks\n    const full_chunks = count / 8\n    for i in 0..full_chunks {\n        // Load 8 contiguous floats directly into SIMD register\n        // Compiles to single VMOVUPS (AVX) or VLD1 (NEON) instruction\n        const chunk = f32x8.load(data[i * 8..])\n        acc = acc + chunk\n    }\n\n    // Horizontal sum: reduce 8 lanes to single value\n    let sum = acc.sum()\n\n    // Handle remaining elements (count % 8)\n    const remainder_start = full_chunks * 8\n    for i in remainder_start..count {\n        sum += data[i]\n    }\n\n    sum\n}\n\n// ============================================================================\n// Main Entry Point\n// ============================================================================\nfunc main() -> () or Error {\n    println(\"=== Real-Time Sensor Processor ===\")\n    println(\"\")\n\n    // Configuration\n    const SAMPLE_RATE_HZ: u32 = 1000        // 1kHz sensor sampling\n    const PROCESS_RATE_HZ: u32 = 100        // 100Hz processing loop\n    const HARD_DEADLINE_US: u64 = 5000      // 5ms hard deadline (50% of period)\n    const DURATION_SECS: u64 = 2            // Run for 2 seconds\n\n    println(\"Sample rate: {SAMPLE_RATE_HZ} Hz (interrupt)\")\n    println(\"Process rate: {PROCESS_RATE_HZ} Hz (main loop)\")\n    println(\"Hard deadline: {HARD_DEADLINE_US} Âµs\")\n    println(\"\")\n\n    // Pre-allocate everything before real-time section\n    let buffer = SpscRingBuffer<SensorReading, 256>.new(SensorReading {\n        sensor_id: 0,\n        value: 0.0,\n        timestamp_ns: 0,\n    })\n    let state = ProcessorState.new()\n    let timing = TimingStats.new()\n    let running = Atomic.new(true)\n\n    const start_time = time.Instant.now()\n    const process_period_ns = 1_000_000_000u64 / PROCESS_RATE_HZ as u64\n    const deadline_ns = HARD_DEADLINE_US * 1000\n\n    // Start interrupt handler on raw thread (needs thread affinity)\n    let isr_handle = spawn_raw {\n        interrupt_handler(buffer, start_time, running, SAMPLE_RATE_HZ)\n    }\n\n    println(\"Started. Processing for {DURATION_SECS} seconds...\")\n    println(\"\")\n\n    // === REAL-TIME SECTION - NO ALLOCATIONS BELOW THIS LINE ===\n\n    let cycle: u64 = 0\n    let next_process_time = start_time\n\n    while time.Instant.now().duration_since(start_time).as_secs() < DURATION_SECS {\n        const cycle_start = time.Instant.now()\n\n        // Drain all available samples from interrupt buffer\n        let drained: u32 = 0\n        while buffer.try_pop() is Some(reading) {\n            state.process_reading(reading)\n            drained += 1\n        }\n\n        // Compute derived values (less frequent)\n        if cycle % 10 == 0 {\n            state.compute_averages()\n        }\n\n        // Measure cycle time\n        const cycle_ns = cycle_start.elapsed().as_nanos()\n        timing.record(cycle_ns, deadline_ns)\n\n        // HARD DEADLINE CHECK - would panic in production\n        if cycle_ns > deadline_ns {\n            // In safety-critical system: trigger watchdog, enter safe mode\n            // Here we just count it\n        }\n\n        cycle += 1\n\n        // Spin-wait for next cycle (more precise than sleep)\n        next_process_time = start_time + time.Duration.from_nanos(process_period_ns * cycle)\n        while time.Instant.now() < next_process_time {\n            core.hint.spin_loop()\n        }\n    }\n\n    // === END REAL-TIME SECTION ===\n\n    // Signal interrupt handler to stop\n    running.store(false, Ordering.Release)\n    try isr_handle.join()\n\n    // Print results\n    println(\"=== Results ===\")\n    println(\"\")\n    println(\"Samples processed: {state.samples_processed}\")\n    println(\"Processing cycles: {cycle}\")\n    println(\"\")\n    println(\"Timing Statistics:\")\n    println(\"  Min cycle:  {timing.min_ns / 1000} Âµs\")\n    println(\"  Max cycle:  {timing.max_ns / 1000} Âµs\")\n    println(\"  Mean cycle: {timing.mean_ns() / 1000} Âµs\")\n    println(\"  Jitter:     {timing.jitter_ns() / 1000} Âµs (std dev)\")\n    println(\"  Deadline misses: {timing.deadline_misses}\")\n    println(\"\")\n    println(\"Final Averages (64-sample window):\")\n    println(\"  Temperature: {state.temp_avg:.2} Â°C\")\n    println(\"  Pressure:    {state.pressure_avg:.1} hPa\")\n    println(\"  Humidity:    {state.humidity_avg:.1} %\")\n\n    if timing.deadline_misses > 0 {\n        println(\"\")\n        println(\"WARNING: {timing.deadline_misses} deadline misses detected!\")\n    }\n\n    Ok(())\n}\n",
    "simple_grep": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Simple grep - Pattern search using module syntax\n// Usage: rask run simple_grep.rk <pattern> <file>\n// Demonstrates: cli.args, fs.read_lines, string methods, match, Vec, loops\n\nimport fs\nimport cli\nimport std\n\nenum GrepResult {\n    Ok(i32)\n    Err(string)\n}\n\nfunc grep_file(pattern: string, path: string) -> GrepResult {\n    const lines_result = fs.read_lines(path)\n\n    match lines_result {\n        Ok(lines) => {\n            let match_count = 0\n            let line_num = 0\n\n            for line in lines {\n                line_num = line_num + 1\n                if line.contains(pattern) {\n                    match_count = match_count + 1\n                    println(\"{line_num}: {line}\")\n                }\n            }\n\n            return GrepResult.Ok(match_count)\n        }\n        Err(e) => return GrepResult.Err(e)\n    }\n}\n\nfunc main() {\n    const args = cli.args()\n    const argc = args.len()\n\n    if argc < 3 {\n        println(\"Usage: rask run simple_grep.rk <pattern> <file>\")\n        std.exit(1)\n    }\n\n    const pattern = args.get(1)\n    const file_path = args.get(2)\n\n    println(\"Searching for '{pattern}' in {file_path}...\")\n\n    const result = grep_file(pattern, file_path)\n\n    match result {\n        Ok(count) => {\n            println(\"\")\n            println(\"Found {count} matching lines\")\n            if count == 0 {\n                std.exit(1)\n            }\n        }\n        Err(e) => {\n            println(\"Error: {e}\")\n            std.exit(2)\n        }\n    }\n}\n",
    "simple_test": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Simple test file for parser testing\n\nfunc add(a: i32, b: i32) -> i32 {\n    return a + b\n}\n\nfunc greet(name: string) {\n    println(\"Hello, {name}\")\n}\n\nstruct Point {\n    x: i32\n    y: i32\n}\n\nfunc main() {\n    const x = 10\n    const y = 20\n    const result = add(x, y)\n    println(\"Result: {result}\")\n}\n",
    "text_editor": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Text Editor with Undo\n// Demonstrates: Pool/Handle pattern, linear resource types, ensure cleanup, command pattern\n\nimport fs\nimport io\n\n// A line in the document\nstruct Line {\n    text: string\n}\n\n// Edit commands that can be undone\nenum EditCommand {\n    InsertLine(after: i32, text: string),\n    DeleteLine(at: i32, deleted_text: string),\n    ModifyLine(at: i32, old_text: string, new_text: string),\n}\n\nextend EditCommand {\n    // Create the inverse command for undo\n    func inverse(self) -> EditCommand {\n        return match self {\n            InsertLine(after, text) => EditCommand.DeleteLine(at: after + 1, deleted_text: text),\n            DeleteLine(at, deleted_text) => EditCommand.InsertLine(after: at - 1, text: deleted_text),\n            ModifyLine(at, old_text, new_text) => EditCommand.ModifyLine(at: at, old_text: new_text, new_text: old_text),\n        }\n    }\n}\n\n// The document model\nstruct Document {\n    lines: Pool<Line>\n    line_order: Vec<Handle<Line>>  // Maintains line ordering\n    undo_stack: Vec<EditCommand>\n    redo_stack: Vec<EditCommand>\n    modified: bool\n}\n\nextend Document {\n    func new() -> Document {\n        return Document {\n            lines: Pool.new(),\n            line_order: Vec.new(),\n            undo_stack: Vec.new(),\n            redo_stack: Vec.new(),\n            modified: false,\n        }\n    }\n\n    func from_file(path: string) -> Document or fs.IoError {\n        const file = try fs.open(path)\n        ensure file.close()\n\n        let doc = Document.new()\n        for line in file.lines() {\n            const text = try line\n            const h = try doc.lines.insert(Line { text: text })\n            try doc.line_order.push(h)\n        }\n        Ok(doc)\n    }\n\n    func line_count(self) -> i32 {\n        return self.line_order.len() as i32\n    }\n\n    func get_line(self, index: i32) -> Option<string> {\n        if index < 0 || index >= self.line_count(): return None\n        const h = self.line_order[index as usize]\n        return Some(self.lines[h].text.clone())\n    }\n\n    // Insert a new line after the given index (-1 for beginning)\n    func insert_line(self, after: i32, text: string) -> () or Error {\n        const h = try self.lines.insert(Line { text: text.clone() })\n        const insert_pos = (after + 1) as usize\n        try self.line_order.insert(insert_pos, h)\n\n        // Record for undo\n        try self.undo_stack.push(EditCommand.InsertLine(after: after, text: text))\n        self.redo_stack.clear()\n        self.modified = true\n    }\n\n    // Delete a line at the given index\n    func delete_line(self, at: i32) -> () or Error {\n        if at < 0 || at >= self.line_count(): return Err(Error.IndexOutOfBounds)\n\n        const h = self.line_order.remove(at as usize)\n        const deleted = self.lines.remove(h).unwrap()\n\n        // Record for undo\n        try self.undo_stack.push(EditCommand.DeleteLine(at: at, deleted_text: deleted.text))\n        self.redo_stack.clear()\n        self.modified = true\n    }\n\n    // Modify text at the given line\n    func modify_line(self, at: i32, new_text: string) -> () or Error {\n        if at < 0 || at >= self.line_count(): return Err(Error.IndexOutOfBounds)\n\n        const h = self.line_order[at as usize]\n        const old_text = self.lines[h].text.clone()\n        self.lines[h].text = new_text.clone()\n\n        // Record for undo\n        try self.undo_stack.push(EditCommand.ModifyLine(at: at, old_text: old_text, new_text: new_text))\n        self.redo_stack.clear()\n        self.modified = true\n    }\n\n    // Undo the last edit\n    func undo(self) -> bool or Error {\n        const cmd = match self.undo_stack.pop() {\n            Some(c) => c,\n            None => return Ok(false),\n        }\n\n        // Apply inverse without recording to undo stack\n        try self.apply_command_silent(cmd.inverse())\n        try self.redo_stack.push(cmd)\n        Ok(true)\n    }\n\n    // Redo the last undone edit\n    func redo(self) -> bool or Error {\n        const cmd = match self.redo_stack.pop() {\n            Some(c) => c,\n            None => return Ok(false),\n        }\n\n        // Apply command without recording to undo stack\n        try self.apply_command_silent(cmd.clone())\n        try self.undo_stack.push(cmd)\n        Ok(true)\n    }\n\n    // Apply a command without recording it\n    func apply_command_silent(self, cmd: EditCommand) -> () or Error {\n        match cmd {\n            InsertLine(after, text) => {\n                const h = try self.lines.insert(Line { text: text })\n                try self.line_order.insert((after + 1) as usize, h)\n            }\n            DeleteLine(at, _) => {\n                const h = self.line_order.remove(at as usize)\n                self.lines.remove(h)\n            }\n            ModifyLine(at, _, new_text) => {\n                const h = self.line_order[at as usize]\n                self.lines[h].text = new_text\n            }\n        }\n        self.modified = true\n    }\n\n    // Save document to file\n    func save(self, path: string) -> () or fs.IoError {\n        const file = try fs.create(path)\n        ensure file.close()\n\n        for h in self.line_order.iter() {\n            try file.write_line(self.lines[h].text)\n        }\n\n        self.modified = false\n        Ok(())\n    }\n\n    // Display the document\n    func display(self) {\n        for i in 0..self.line_count() {\n            const line = self.get_line(i).unwrap()\n            println(\"{i + 1}: {line}\")\n        }\n    }\n}\n\n// Simple command parser for the editor REPL\nenum EditorCommand {\n    Insert(after: i32, text: string),\n    Delete(line: i32),\n    Edit(line: i32, text: string),\n    Undo,\n    Redo,\n    Save(path: string),\n    Print,\n    Quit,\n    Help,\n}\n\nfunc parse_command(input: string) -> Option<EditorCommand> {\n    const parts: Vec<string> = Vec.new()\n    for part in input.trim().split_whitespace() {\n        try parts.push(part.to_owned())\n    }\n    if parts.is_empty(): return None\n\n    return match parts[0] {\n        \"i\" | \"insert\" if parts.len() >= 3 => {\n            const after = try parts[1].parse<i32>().ok()\n            const text = parts[2..].join(\" \")\n            Some(EditorCommand.Insert(after: after, text: text))\n        }\n        \"d\" | \"delete\" if parts.len() >= 2 => {\n            const line = try parts[1].parse<i32>().ok()\n            Some(EditorCommand.Delete(line: line))\n        }\n        \"e\" | \"edit\" if parts.len() >= 3 => {\n            const line = try parts[1].parse<i32>().ok()\n            const text = parts[2..].join(\" \")\n            Some(EditorCommand.Edit(line: line, text: text))\n        }\n        \"u\" | \"undo\" => Some(EditorCommand.Undo),\n        \"r\" | \"redo\" => Some(EditorCommand.Redo),\n        \"w\" | \"save\" if parts.len() >= 2 => Some(EditorCommand.Save(path: parts[1].clone())),\n        \"p\" | \"print\" => Some(EditorCommand.Print),\n        \"q\" | \"quit\" => Some(EditorCommand.Quit),\n        \"h\" | \"help\" => Some(EditorCommand.Help),\n        _ => None,\n    }\n}\n\nfunc print_help() {\n    println(\"Commands:\")\n    println(\"  i/insert <line> <text>  - Insert text after line (0 for beginning)\")\n    println(\"  d/delete <line>         - Delete line\")\n    println(\"  e/edit <line> <text>    - Replace line content\")\n    println(\"  u/undo                  - Undo last change\")\n    println(\"  r/redo                  - Redo last undone change\")\n    println(\"  w/save <path>           - Save to file\")\n    println(\"  p/print                 - Print document\")\n    println(\"  q/quit                  - Quit editor\")\n    println(\"  h/help                  - Show this help\")\n}\n\nfunc main() -> () or Error {\n    let doc = Document.new()\n\n    println(\"Simple Text Editor - type 'help' for commands\")\n\n    loop {\n        print(\"> \")\n        const input = try io.read_line()\n\n        const cmd = match parse_command(input) {\n            Some(c) => c,\n            None => {\n                println(\"Unknown command. Type 'help' for usage.\")\n                continue\n            }\n        }\n\n        match cmd {\n            Insert(after, text) => {\n                try doc.insert_line(after, text)\n                println(\"Inserted line\")\n            }\n            Delete(line) => {\n                try doc.delete_line(line - 1)  // 1-indexed to 0-indexed\n                println(\"Deleted line {line}\")\n            }\n            Edit(line, text) => {\n                try doc.modify_line(line - 1, text)\n                println(\"Modified line {line}\")\n            }\n            Undo => {\n                if try doc.undo(): println(\"Undone\") else: println(\"Nothing to undo\")\n            }\n            Redo => {\n                if try doc.redo(): println(\"Redone\") else: println(\"Nothing to redo\")\n            }\n            Save(path) => {\n                try doc.save(path.clone())\n                println(\"Saved to {path}\")\n            }\n            Print => doc.display(),\n            Quit => {\n                if doc.modified {\n                    println(\"Warning: unsaved changes\")\n                }\n                break\n            }\n            Help => print_help(),\n        }\n    }\n\n    return Ok(())\n}\n"
};

export const EXAMPLE_METADATA = [
    {
        "key": "01_variables",
        "title": "01 Variables",
        "file": "01_variables.rk"
    },
    {
        "key": "02_functions",
        "title": "02 Functions",
        "file": "02_functions.rk"
    },
    {
        "key": "03_collections",
        "title": "03 Collections",
        "file": "03_collections.rk"
    },
    {
        "key": "04_pattern_matching",
        "title": "04 Pattern Matching",
        "file": "04_pattern_matching.rk"
    },
    {
        "key": "05_loops",
        "title": "05 Loops",
        "file": "05_loops.rk"
    },
    {
        "key": "06_structs",
        "title": "06 Structs",
        "file": "06_structs.rk"
    },
    {
        "key": "07_error_handling",
        "title": "07 Error Handling",
        "file": "07_error_handling.rk"
    },
    {
        "key": "08_traits",
        "title": "08 Traits",
        "file": "08_traits.rk"
    },
    {
        "key": "09_generics",
        "title": "09 Generics",
        "file": "09_generics.rk"
    },
    {
        "key": "10_enums_advanced",
        "title": "10 Enums Advanced",
        "file": "10_enums_advanced.rk"
    },
    {
        "key": "11_closures",
        "title": "11 Closures",
        "file": "11_closures.rk"
    },
    {
        "key": "12_iterators",
        "title": "12 Iterators",
        "file": "12_iterators.rk"
    },
    {
        "key": "13_string_operations",
        "title": "13 String Operations",
        "file": "13_string_operations.rk"
    },
    {
        "key": "14_borrowing_patterns",
        "title": "14 Borrowing Patterns",
        "file": "14_borrowing_patterns.rk"
    },
    {
        "key": "15_memory_management",
        "title": "15 Memory Management",
        "file": "15_memory_management.rk"
    },
    {
        "key": "16_concurrency_basics",
        "title": "16 Concurrency Basics",
        "file": "16_concurrency_basics.rk"
    },
    {
        "key": "17_comptime",
        "title": "17 Comptime",
        "file": "17_comptime.rk"
    },
    {
        "key": "18_resource_types",
        "title": "18 Resource Types",
        "file": "18_resource_types.rk"
    },
    {
        "key": "19_unsafe",
        "title": "19 Unsafe",
        "file": "19_unsafe.rk"
    },
    {
        "key": "cli_calculator",
        "title": "Cli Calculator",
        "file": "cli_calculator.rk"
    },
    {
        "key": "collections_test",
        "title": "Collections Test",
        "file": "collections_test.rk"
    },
    {
        "key": "file_copy",
        "title": "File Copy",
        "file": "file_copy.rk"
    },
    {
        "key": "game_loop",
        "title": "Game Loop",
        "file": "game_loop.rk"
    },
    {
        "key": "grep_clone",
        "title": "Grep Clone",
        "file": "grep_clone.rk"
    },
    {
        "key": "hello_world",
        "title": "Hello World",
        "file": "hello_world.rk"
    },
    {
        "key": "http_api_server",
        "title": "Http Api Server",
        "file": "http_api_server.rk"
    },
    {
        "key": "pool_test",
        "title": "Pool Test",
        "file": "pool_test.rk"
    },
    {
        "key": "sensor_processor",
        "title": "Sensor Processor",
        "file": "sensor_processor.rk"
    },
    {
        "key": "simple_grep",
        "title": "Simple Grep",
        "file": "simple_grep.rk"
    },
    {
        "key": "simple_test",
        "title": "Simple Test",
        "file": "simple_test.rk"
    },
    {
        "key": "text_editor",
        "title": "Text Editor",
        "file": "text_editor.rk"
    }
];

export const DEFAULT_CODE = EXAMPLES.hello_world || `func main() {
    println("Hello, World!")
}`;
