// SPDX-License-Identifier: (MIT OR Apache-2.0)
// Auto-generated from examples/*.rk files
// Run: node build-examples.js

export const EXAMPLES = {
    "01_variables": "// Learn: Variables and basic types\n\nfunc main() {\n    // const - binding won't be reassigned\n    const name = \"Alice\"\n    const age = 30\n    const height = 1.75\n\n    print(\"Name: \")\n    print(name)\n    print(\"\\n\")\n\n    print(\"Age: \")\n    print(age)\n    print(\"\\n\")\n\n    // let - binding can be reassigned\n    let counter = 0\n    counter = counter + 1\n    counter = counter + 1\n\n    print(\"Counter: \")\n    print(counter)\n    print(\"\\n\")\n}\n",
    "02_functions": "// Learn: Functions and return values\n\nfunc main() {\n    const result = add(5, 3)\n    print(\"5 + 3 = \")\n    print(result)\n    print(\"\\n\")\n\n    const doubled = double(7)\n    print(\"7 × 2 = \")\n    print(doubled)\n    print(\"\\n\")\n\n    greet(\"World\")\n}\n\nfunc add(a: i32, b: i32) -> i32 {\n    return a + b\n}\n\nfunc double(x: i32) -> i32 {\n    return x * 2\n}\n\nfunc greet(name: string) {\n    print(\"Hello, \")\n    print(name)\n    print(\"!\\n\")\n}\n",
    "03_collections": "// Learn: Vec and Map collections\n\nfunc main() {\n    // Vec - ordered collection\n    const numbers = Vec.from([1, 2, 3, 4, 5])\n\n    print(\"Vec length: \")\n    print(numbers.len())\n    print(\"\\n\")\n\n    print(\"Numbers: \")\n    print(numbers.join(\", \"))\n    print(\"\\n\")\n\n    // Map - key-value pairs\n    const scores = Map.new()\n    try scores.insert(\"Alice\", 95)\n    try scores.insert(\"Bob\", 87)\n    try scores.insert(\"Charlie\", 92)\n\n    const alice_score = scores.get(\"Alice\")\n    if alice_score is Some(score) {\n        print(\"Alice's score: \")\n        print(score)\n        print(\"\\n\")\n    }\n\n    print(\"Total students: \")\n    print(scores.len())\n    print(\"\\n\")\n}\n",
    "04_pattern_matching": "// Learn: Pattern matching with match and if-is\n\nfunc main() {\n    // Match expression\n    const x = 2\n    const name = match x {\n        1 => \"one\",\n        2 => \"two\",\n        3 => \"three\",\n        _ => \"many\",\n    }\n\n    print(\"Number \")\n    print(x)\n    print(\" is \")\n    print(name)\n    print(\"\\n\")\n\n    // Pattern matching with Option\n    const maybe = Some(42)\n\n    if maybe is Some(value) {\n        print(\"Got value: \")\n        print(value)\n        print(\"\\n\")\n    }\n\n    const nothing = None\n\n    if nothing is None {\n        print(\"Got nothing\\n\")\n    }\n}\n",
    "05_loops": "// Learn: For loops and iteration\n\nfunc main() {\n    // Loop over range\n    print(\"Counting 1 to 5:\\n\")\n    for i in 1..6 {\n        print(i)\n        print(\" \")\n    }\n    print(\"\\n\\n\")\n\n    // Loop over Vec\n    const fruits = Vec.from([\"apple\", \"banana\", \"cherry\"])\n\n    print(\"Fruits:\\n\")\n    for fruit in fruits.iter() {\n        print(\"- \")\n        print(fruit)\n        print(\"\\n\")\n    }\n\n    // While loop\n    let count = 0\n    print(\"\\nWhile counting:\\n\")\n    while count < 3 {\n        print(count)\n        print(\" \")\n        count = count + 1\n    }\n    print(\"\\n\")\n}\n",
    "06_structs": "// Learn: Structs and methods\n\nstruct Person {\n    name: string,\n    age: i32,\n}\n\nextend Person {\n    func greet(self) {\n        print(\"Hello, I'm \")\n        print(self.name)\n        print(\" and I'm \")\n        print(self.age)\n        print(\" years old.\\n\")\n    }\n\n    func is_adult(self) -> bool {\n        return self.age >= 18\n    }\n}\n\nfunc main() {\n    const alice = Person {\n        name: \"Alice\",\n        age: 25,\n    }\n\n    alice.greet()\n\n    if alice.is_adult() {\n        print(\"Alice is an adult\\n\")\n    }\n\n    const bob = Person {\n        name: \"Bob\",\n        age: 16,\n    }\n\n    bob.greet()\n\n    if !bob.is_adult() {\n        print(\"Bob is not an adult yet\\n\")\n    }\n}\n",
    "07_error_handling": "// Learn: Error handling with Result and try\n\nfunc main() {\n    // Handling Result with match\n    const result = divide(10, 2)\n\n    match result {\n        Ok(value) => {\n            print(\"10 / 2 = \")\n            print(value)\n            print(\"\\n\")\n        }\n        Err(msg) => {\n            print(\"Error: \")\n            print(msg)\n            print(\"\\n\")\n        }\n    }\n\n    // Division by zero\n    const bad = divide(10, 0)\n\n    match bad {\n        Ok(value) => {\n            print(\"Result: \")\n            print(value)\n            print(\"\\n\")\n        }\n        Err(msg) => {\n            print(\"Error: \")\n            print(msg)\n            print(\"\\n\")\n        }\n    }\n\n    // Using try operator\n    const safe = safe_calc()\n    print(\"Safe calc result: \")\n    print(safe)\n    print(\"\\n\")\n}\n\nfunc divide(a: i32, b: i32) -> i32 or string {\n    if b == 0 {\n        return Err(\"Cannot divide by zero\")\n    }\n    return Ok(a / b)\n}\n\nfunc safe_calc() -> i32 {\n    const x = divide(20, 4)\n    if x is Ok(value) {\n        return value * 2\n    }\n    return 0\n}\n",
    "cli_calculator": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\nimport io\n\n// CLI Calculator - Expression Evaluator\n// Demonstrates: Parsing, enums, match expressions, error handling, REPL pattern\n\n// Token types from lexer\nenum Token {\n    Number(f64),\n    Plus,\n    Minus,\n    Star,\n    Slash,\n    Percent,\n    Caret,       // Power\n    LParen,\n    RParen,\n    Eof,\n}\n\n// AST nodes\nenum Expr {\n    Number(f64),\n    Binary(left: Owned<Expr>, op: BinaryOp, right: Owned<Expr>),\n    Unary(op: UnaryOp, expr: Owned<Expr>),\n}\n\nenum BinaryOp {\n    Add,\n    Sub,\n    Mul,\n    Div,\n    Mod,\n    Pow,\n}\n\nenum UnaryOp {\n    Neg,\n}\n\nenum CalcError {\n    UnexpectedChar(char),\n    UnexpectedToken(string),\n    DivisionByZero,\n    EmptyExpression,\n}\n\nextend CalcError {\n    func message(self) -> string {\n        match self {\n            UnexpectedChar(c) => return \"unexpected character: '{c}'\",\n            UnexpectedToken(s) => return \"unexpected token: {s}\",\n            DivisionByZero => return \"division by zero\",\n            EmptyExpression => return \"empty expression\",\n        }\n    }\n}\n\n// Lexer\nstruct Lexer {\n    input: string\n    pos: usize\n}\n\nextend Lexer {\n    func new(input: string) -> Lexer {\n        return Lexer { input: input, pos: 0 as usize }\n    }\n\n    func peek_char(self) -> char? {\n        if self.pos >= self.input.len(): return None\n        self.input.char_at(self.pos)\n    }\n\n    func advance(self) -> char? {\n        const c = try self.peek_char()\n        self.pos += 1\n        Some(c)\n    }\n\n    func skip_whitespace(self) {\n        while self.peek_char() is Some(c) {\n            if !c.is_whitespace(): break\n            self.advance()\n        }\n    }\n\n    func next_token(self) -> Token or CalcError {\n        self.skip_whitespace()\n\n        const c = match self.peek_char() {\n            Some(c) => c,\n            None => return Ok(Token.Eof),\n        }\n\n        // Single-character tokens\n        const token = match c {\n            '+' => { self.advance(); Token.Plus }\n            '-' => { self.advance(); Token.Minus }\n            '*' => { self.advance(); Token.Star }\n            '/' => { self.advance(); Token.Slash }\n            '%' => { self.advance(); Token.Percent }\n            '^' => { self.advance(); Token.Caret }\n            '(' => { self.advance(); Token.LParen }\n            ')' => { self.advance(); Token.RParen }\n            _ if c.is_digit() || c == '.' => try self.read_number(),\n            _ => return Err(CalcError.UnexpectedChar(c)),\n        }\n\n        Ok(token)\n    }\n\n    func read_number(self) -> Token or CalcError {\n        const num_str = string.new()\n        let has_dot = false\n\n        while self.peek_char() is Some(c) {\n            if c.is_digit() {\n                num_str.push(c)\n                self.advance()\n            } else if c == '.' && !has_dot {\n                has_dot = true\n                num_str.push(c)\n                self.advance()\n            } else {\n                break\n            }\n        }\n\n        const value: f64 = num_str.parse().unwrap()\n        Ok(Token.Number(value))\n    }\n}\n\n// Parser with operator precedence\nstruct Parser {\n    lexer: Lexer\n    current: Token\n}\n\nextend Parser {\n    func new(input: string) -> Parser or CalcError {\n        const lexer = Lexer.new(input)\n        const current = try lexer.next_token()\n        Ok(Parser { lexer: lexer, current: current })\n    }\n\n    func advance(self) -> () or CalcError {\n        self.current = try self.lexer.next_token()\n    }\n\n    func parse(self) -> Expr or CalcError {\n        const expr = try self.parse_expression()\n\n        match self.current {\n            Eof => return Ok(expr),\n            _ => return Err(CalcError.UnexpectedToken(self.token_string())),\n        }\n    }\n    \n\n    func token_string(self) -> string {\n        match self.current {\n            Number(n) => return \"{n}\",\n            Plus => return \"+\",\n            Minus => return \"-\",\n            Star => return \"*\",\n            Slash => return \"/\",\n            Percent => return \"%\",\n            Caret => return \"^\",\n            LParen => return \"(\",\n            RParen => return \")\",\n            Eof => return \"end of input\",\n        }\n    }\n\n    // expression = term (('+' | '-') term)*\n    func parse_expression(self) -> Expr or CalcError {\n        let left = try self.parse_term()\n\n        loop {\n            const op = match self.current {\n                Plus => BinaryOp.Add,\n                Minus => BinaryOp.Sub,\n                _ => break,\n            }\n            try self.advance()\n            const right = try self.parse_term()\n            left = Expr.Binary(left: own left, op: op, right: own right)\n        }\n\n        Ok(left)\n    }\n\n    // term = power (('*' | '/' | '%') power)*\n    func parse_term(self) -> Expr or CalcError {\n        let left = try self.parse_power()\n\n        loop {\n            const op = match self.current {\n                Star => BinaryOp.Mul,\n                Slash => BinaryOp.Div,\n                Percent => BinaryOp.Mod,\n                _ => break,\n            }\n            try self.advance()\n            const right = try self.parse_power()\n            left = Expr.Binary(left: own left, op: op, right: own right)\n        }\n\n        Ok(left)\n    }\n\n    // power = unary ('^' power)?  (right associative)\n    func parse_power(self) -> Expr or CalcError {\n        const base = try self.parse_unary()\n\n        if self.current is Caret {\n            try self.advance()\n            const exp = try self.parse_power()  // Right associative\n            return Ok(Expr.Binary(left: own base, op: BinaryOp.Pow, right: own exp))\n        } else {\n            return Ok(base)\n        }\n    }\n\n    // unary = '-' unary | primary\n    func parse_unary(self) -> Expr or CalcError {\n        if self.current is Minus {\n            try self.advance()\n            const expr = try self.parse_unary()\n            return Ok(Expr.Unary(op: UnaryOp.Neg, expr: own expr))\n        } else {\n            return self.parse_primary()\n        }\n    }\n\n    // primary = NUMBER | '(' expression ')'\n    func parse_primary(self) -> Expr or CalcError {\n        match self.current {\n            Number(n) => {\n                try self.advance()\n                return Ok(Expr.Number(n))\n            }\n            LParen => {\n                try self.advance()\n                const expr = try self.parse_expression()\n                match self.current {\n                    RParen => {\n                        try self.advance()\n                        return Ok(expr)\n                    }\n                    _ => return Err(CalcError.UnexpectedToken(\"expected ')'\".to_string())),\n                }\n            }\n            Eof => return Err(CalcError.EmptyExpression),\n            _ => return Err(CalcError.UnexpectedToken(self.token_string())),\n        }\n    }\n}\n\n// Evaluator\nfunc evaluate(expr: Expr) -> f64 or CalcError {\n    match expr {\n        Number(n) => return Ok(n),\n        Unary(op, inner) => {\n            const val = try evaluate(inner)\n            match op {\n                Neg => return Ok(-val),\n            }\n        }\n        Binary(left, op, right) => {\n            const l = try evaluate(left)\n            const r = try evaluate(right)\n            match op {\n                Add => return Ok(l + r),\n                Sub => return Ok(l - r),\n                Mul => return Ok(l * r),\n                Div => {\n                    if r == 0.0: return Err(CalcError.DivisionByZero)\n                    return Ok(l / r)\n                }\n                Mod => {\n                    if r == 0.0: return Err(CalcError.DivisionByZero)\n                    return Ok(l % r)\n                }\n                Pow => return Ok(l.powf(r)),\n            }\n        }\n    }\n}\n\nfunc calc(input: string) -> f64 or CalcError {\n    const parser = try Parser.new(input)\n    const expr = try parser.parse()\n    evaluate(expr)\n}\n\nfunc print_help() {\n    println(\"Calculator - Enter expressions to evaluate\")\n    println(\"\")\n    println(\"Operators:\")\n    println(\"  + - * /  Basic arithmetic\")\n    println(\"  %        Modulo\")\n    println(\"  ^        Power (right associative)\")\n    println(\"  ( )      Grouping\")\n    println(\"\")\n    println(\"Examples:\")\n    println(\"  2 + 3 * 4      => 14\")\n    println(\"  (2 + 3) * 4    => 20\")\n    println(\"  2 ^ 3 ^ 2      => 512 (right associative)\")\n    println(\"  -5 + 3         => -2\")\n    println(\"\")\n    println(\"Commands:\")\n    println(\"  help     Show this help\")\n    println(\"  quit     Exit calculator\")\n}\n\nfunc main() -> () or Error {\n    println(\"Rask Calculator\")\n    println(\"Type 'help' for usage, 'quit' to exit\")\n    println(\"\")\n\n    loop {\n        print(\"> \")\n        const input = (try io.read_line()).trim()\n\n        if input.is_empty(): continue\n\n        match input {\n            \"quit\" | \"exit\" | \"q\" => break,\n            \"help\" | \"h\" | \"?\" => print_help(),\n            _ => {\n                match calc(input.to_string()) {\n                    Ok(result) => println(\"= {result}\"),\n                    Err(e) => println(\"Error: {e.message()}\"),\n                }\n            }\n        }\n    }\n\n    println(\"Goodbye!\")\n}\n\n// ============================================================================\n// Tests - Demonstrates test blocks and assert statements\n// ============================================================================\n\ntest \"addition\" {\n    assert calc(\"2 + 3\") == Ok(5.0)\n    assert calc(\"10 + 20 + 30\") == Ok(60.0)\n}\n\ntest \"subtraction\" {\n    assert calc(\"10 - 3\") == Ok(7.0)\n    assert calc(\"5 - 10\") == Ok(-5.0)\n}\n\ntest \"multiplication\" {\n    assert calc(\"4 * 5\") == Ok(20.0)\n    assert calc(\"2 * 3 * 4\") == Ok(24.0)\n}\n\ntest \"division\" {\n    assert calc(\"20 / 4\") == Ok(5.0)\n    assert calc(\"7 / 2\") == Ok(3.5)\n}\n\ntest \"precedence\" {\n    // Multiplication before addition\n    assert calc(\"2 + 3 * 4\") == Ok(14.0)\n    assert calc(\"2 * 3 + 4\") == Ok(10.0)\n\n    // Division before subtraction\n    assert calc(\"10 - 6 / 2\") == Ok(7.0)\n}\n\ntest \"parentheses\" {\n    assert calc(\"(2 + 3) * 4\") == Ok(20.0)\n    assert calc(\"2 * (3 + 4)\") == Ok(14.0)\n    assert calc(\"((1 + 2) * (3 + 4))\") == Ok(21.0)\n}\n\ntest \"power right associative\" {\n    // 2^3^2 = 2^(3^2) = 2^9 = 512, not (2^3)^2 = 64\n    assert calc(\"2 ^ 3 ^ 2\") == Ok(512.0)\n    assert calc(\"2 ^ 3\") == Ok(8.0)\n}\n\ntest \"unary negation\" {\n    assert calc(\"-5\") == Ok(-5.0)\n    assert calc(\"-5 + 3\") == Ok(-2.0)\n    assert calc(\"--5\") == Ok(5.0)  // Double negation\n    assert calc(\"3 * -2\") == Ok(-6.0)\n}\n\ntest \"modulo\" {\n    assert calc(\"10 % 3\") == Ok(1.0)\n    assert calc(\"15 % 4\") == Ok(3.0)\n}\n\ntest \"floating point\" {\n    assert calc(\"3.14 * 2\") == Ok(6.28)\n    assert calc(\"1.5 + 2.5\") == Ok(4.0)\n}\n\ntest \"division by zero\" {\n    assert calc(\"5 / 0\") == Err(CalcError.DivisionByZero)\n    assert calc(\"10 % 0\") == Err(CalcError.DivisionByZero)\n}\n\ntest \"invalid input\" {\n    assert calc(\"2 +\").is_err()\n    assert calc(\"\") == Err(CalcError.EmptyExpression)\n    assert calc(\"@\").is_err()\n}\n",
    "collections_test": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Collections test - Vec, struct literals, match expressions\n// Step 9 validation\n\nstruct Point {\n    x: i32\n    y: i32\n}\n\nfunc main() {\n    // Vec basics\n    const v = Vec.new()\n    v.push(10)\n    v.push(20)\n    v.push(30)\n    const vlen = v.len()\n    println(\"Vec length: {vlen}\")\n    const v0 = v.get(0)\n    const v1 = v.get(1)\n    const v2 = v.get(2)\n    println(\"v[0] = {v0}\")\n    println(\"v[1] = {v1}\")\n    println(\"v[2] = {v2}\")\n\n    // Vec iteration\n    println(\"Iterating:\")\n    for item in v {\n        println(\"  item: {item}\")\n    }\n\n    // Array literal\n    const arr = [1, 2, 3, 4, 5]\n    const arrlen = arr.len()\n    println(\"Array length: {arrlen}\")\n\n    // Struct instantiation\n    const p = Point { x: 100, y: 200 }\n    const px = p.x\n    const py = p.y\n    println(\"Point: x={px}, y={py}\")\n\n    // Match on integers\n    const num = 2\n    const result = match num {\n        1 => \"one\",\n        2 => \"two\",\n        3 => \"three\",\n        _ => \"other\",\n    }\n    println(\"match result: {result}\")\n\n    println(\"Collections test passed!\")\n}\n",
    "file_copy": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// File Copy Utility\n// Demonstrates: CLI arg parsing, structs, enums, match, error propagation,\n//               closures (map_err), string interpolation, file I/O\n\nimport fs\nimport cli\nimport std\n\nenum CopyError {\n    SourceNotFound(string),\n    DestinationExists(string),\n    ReadError(string),\n    WriteError(string),\n    SameFile,\n}\n\nextend CopyError {\n    func message(self) -> string {\n        match self {\n            SourceNotFound(path) => return \"source file not found: {path}\",\n            DestinationExists(path) => return \"destination already exists: {path} (use -f to overwrite)\",\n            ReadError(msg) => return \"read error: {msg}\",\n            WriteError(msg) => return \"write error: {msg}\",\n            SameFile => return \"source and destination are the same file\",\n        }\n    }\n}\n\nstruct CopyOptions {\n    source: string\n    dest: string\n    force: bool\n    verbose: bool\n}\n\nfunc parse_args(args: Vec<string>) -> CopyOptions or string {\n    let opts = CopyOptions {\n        source: \"\",\n        dest: \"\",\n        force: false,\n        verbose: false,\n    }\n\n    let positional = Vec.new()\n\n    for arg in args.iter().skip(1) {\n        match arg {\n            \"-f\" | \"--force\" => opts.force = true,\n            \"-v\" | \"--verbose\" => opts.verbose = true,\n            \"-h\" | \"--help\" => {\n                print_usage()\n                std.exit(0)\n            }\n            _ => positional.push(arg.clone()),\n        }\n    }\n\n    if positional.len() < 2 {\n        return Err(\"usage: rcopy [-fv] SOURCE DEST\")\n    }\n\n    opts.source = positional[0].clone()\n    opts.dest = positional[1].clone()\n\n    return Ok(opts)\n}\n\nfunc print_usage() {\n    println(\"Usage: rcopy [OPTIONS] SOURCE DEST\")\n    println(\"\")\n    println(\"Copy SOURCE to DEST\")\n    println(\"\")\n    println(\"Options:\")\n    println(\"  -f, --force     Overwrite destination if it exists\")\n    println(\"  -v, --verbose   Show progress information\")\n    println(\"  -h, --help      Show this help\")\n}\n\nfunc copy_file(opts: CopyOptions) -> i64 or CopyError {\n    // Check source exists\n    if !fs.exists(opts.source.clone()) {\n        return Err(CopyError.SourceNotFound(opts.source))\n    }\n\n    // Check destination\n    if fs.exists(opts.dest.clone()) {\n        if !opts.force {\n            return Err(CopyError.DestinationExists(opts.dest))\n        }\n    }\n\n    // Check not same file (using canonical paths)\n    const src_canonical = try fs.canonicalize(opts.source.clone())\n        .map_err(|e| CopyError.ReadError(e))\n    const dst_canonical = fs.canonicalize(opts.dest.clone()).ok()\n\n    if dst_canonical is Some(dst) {\n        if src_canonical == dst {\n            return Err(CopyError.SameFile)\n        }\n    }\n\n    // Copy the file\n    const bytes = try fs.copy(opts.source.clone(), opts.dest.clone())\n        .map_err(|e| CopyError.WriteError(e))\n\n    return Ok(bytes)\n}\n\nfunc format_size(bytes: i64) -> string {\n    if bytes < 1024 {\n        return \"{bytes} B\"\n    } else if bytes < 1048576 {\n        const kb = bytes / 1024\n        return \"{kb} KB\"\n    } else {\n        const mb = bytes / 1048576\n        return \"{mb} MB\"\n    }\n}\n\nfunc main() {\n    const args = cli.args()\n\n    const opts = match parse_args(args) {\n        Ok(o) => o,\n        Err(msg) => {\n            println(\"rcopy: {msg}\")\n            std.exit(1)\n        }\n    }\n\n    if opts.verbose {\n        println(\"Copying '{opts.source}' to '{opts.dest}'...\")\n    }\n\n    match copy_file(opts.clone()) {\n        Ok(bytes) => {\n            if opts.verbose {\n                const size = format_size(bytes)\n                println(\"Copied {size}\")\n            }\n        }\n        Err(e) => {\n            const msg = e.message()\n            println(\"rcopy: {msg}\")\n            std.exit(1)\n        }\n    }\n}\n",
    "game_loop": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Game Loop with Entities\n// Demonstrates: Pool pattern, handle-based refs, traits, threading, time/delta, game systems\n\nimport time\nimport random\n\n// Trait for updatable components\ntrait Updatable {\n    func update(self, dt: f32)\n}\n\n// Position implements Updatable (applies velocity)\nextend Position with Updatable {\n    func update(self, dt: f32) {\n        // Position updated by movement system\n    }\n}\n\n// Component types\nstruct Position {\n    x: f32\n    y: f32\n}\n\nstruct Velocity {\n    dx: f32\n    dy: f32\n}\n\nstruct Health {\n    current: i32\n    max: i32\n}\n\nstruct Collider {\n    radius: f32\n}\n\n// Entity with all components\nstruct Entity {\n    position: Position\n    velocity: Velocity\n    health: Health\n    collider: Collider\n    active: bool\n    entity_type: EntityType\n}\n\nenum EntityType {\n    Player,\n    Enemy,\n    Projectile,\n}\n\n// Game state\nstruct GameState {\n    entities: Pool<Entity>\n    player: Handle<Entity>?\n    score: i32\n    game_over: bool\n}\n\nextend GameState {\n    func new() -> GameState or Error {\n        let entities = Pool.new()\n\n        // Spawn player at center\n        const player_handle = try entities.insert(Entity {\n            position: Position { x: 400.0f32, y: 300.0f32 },\n            velocity: Velocity { dx: 0.0f32, dy: 0.0f32 },\n            health: Health { current: 100, max: 100 },\n            collider: Collider { radius: 16.0f32 },\n            active: true,\n            entity_type: EntityType.Player,\n        })\n\n        return Ok(GameState {\n            entities: entities,\n            player: Some(player_handle),\n            score: 0,\n            game_over: false,\n        })\n    }\n\n    func spawn_enemy(self, x: f32, y: f32) -> Handle<Entity> or Error {\n        return self.entities.insert(Entity {\n            position: Position { x: x, y: y },\n            velocity: Velocity { dx: -50.0f32, dy: 0.0f32 },\n            health: Health { current: 20, max: 20 },\n            collider: Collider { radius: 12.0f32 },\n            active: true,\n            entity_type: EntityType.Enemy,\n        })\n    }\n\n    func spawn_projectile(self, x: f32, y: f32, dx: f32, dy: f32) -> Handle<Entity> or Error {\n        return self.entities.insert(Entity {\n            position: Position { x: x, y: y },\n            velocity: Velocity { dx: dx, dy: dy },\n            health: Health { current: 1, max: 1 },\n            collider: Collider { radius: 4.0f32 },\n            active: true,\n            entity_type: EntityType.Projectile,\n        })\n    }\n}\n\n// System: Update positions based on velocities\n// here we only use the entities pool from GameState, so we can use a projection\n// This allows us to avoid borrowing the entire GameState\nfunc movement_system(entities: GameState.{entities}, dt: f32) {\n    for h in entities {\n        if !entities[h].active: continue\n\n        entities[h].position.x += entities[h].velocity.dx * dt\n        entities[h].position.y += entities[h].velocity.dy * dt\n    }\n}\n\n// System: Check collisions between entities\nfunc collision_system(state: GameState) {\n    let to_check = state.entities.handles()\n\n    for i in 0..to_check.len() {\n        for j in (i + 1)..to_check.len() {\n            const h1 = to_check[i]\n            const h2 = to_check[j]\n\n            if !state.entities[h1].active || !state.entities[h2].active: continue\n\n            const e1 = state.entities[h1]\n            const e2 = state.entities[h2]\n\n            // Calculate distance\n            const dx = e1.position.x - e2.position.x\n            const dy = e1.position.y - e2.position.y\n            const dist = (dx * dx + dy * dy).sqrt()\n            const min_dist = e1.collider.radius + e2.collider.radius\n\n            if dist < min_dist {\n                handle_collision(state, h1, h2)\n            }\n        }\n    }\n}\n\nfunc handle_collision(state: GameState, h1: Handle<Entity>, h2: Handle<Entity>) {\n    const type1 = state.entities[h1].entity_type\n    const type2 = state.entities[h2].entity_type\n\n    // Player vs Enemy\n    if (type1 == EntityType.Player && type2 == EntityType.Enemy) ||\n       (type1 == EntityType.Enemy && type2 == EntityType.Player) {\n        const player_h = if type1 == EntityType.Player: h1 else: h2\n        const enemy_h = if type1 == EntityType.Enemy: h1 else: h2\n\n        state.entities[player_h].health.current -= 10\n        state.entities[enemy_h].active = false\n\n        if state.entities[player_h].health.current <= 0 {\n            state.game_over = true\n        }\n    }\n\n    // Projectile vs Enemy\n    if (type1 == EntityType.Projectile && type2 == EntityType.Enemy) ||\n       (type1 == EntityType.Enemy && type2 == EntityType.Projectile) {\n        const enemy_h = if type1 == EntityType.Enemy: h1 else: h2\n        const proj_h = if type1 == EntityType.Projectile: h1 else: h2\n\n        state.entities[enemy_h].health.current -= 25\n        state.entities[proj_h].active = false\n\n        if state.entities[enemy_h].health.current <= 0 {\n            state.entities[enemy_h].active = false\n            state.score += 100\n        }\n    }\n}\n\n// System: Remove inactive entities\nfunc cleanup_system(state: GameState) {\n    let to_remove = Vec.new()\n\n    for h in state.entities {\n        if !state.entities[h].active {\n            to_remove.push(h).ok()\n        }\n    }\n\n    for h in to_remove {\n        state.entities.remove(h)\n    }\n}\n\n// System: Spawn enemies periodically\nfunc spawn_system(state: GameState, time_since_last_spawn: f32) -> f32 {\n    const spawn_interval = 2.0f32\n\n    if time_since_last_spawn >= spawn_interval {\n        // Spawn enemy at right edge with random y\n        const y = (random.f32() * 500.0f32) + 50.0f32\n        state.spawn_enemy(850.0f32, y).ok()\n        return 0.0f32  // Reset timer\n    } else {\n        return time_since_last_spawn\n    }\n}\n\n// Parallel movement update - processes entity batches across threads\nfunc parallel_movement_system(entities: GameState.{entities}, dt: f32, num_threads: usize) {\n    let handles = entities.handles()\n    let chunk_size = (handles.len() + num_threads - 1) / num_threads\n\n    // Split work across thread pool\n    let thread_handles = Vec.new()\n    for chunk in handles.chunks(chunk_size) {\n        let chunk = chunk.to_vec()\n        let task = spawn_thread {\n            for h in chunk {\n                if !entities[h].active: continue\n                entities[h].position.x += entities[h].velocity.dx * dt\n                entities[h].position.y += entities[h].velocity.dy * dt\n            }\n        }\n        thread_handles.push(task).ok()\n    }\n\n    // Wait for all chunks to complete\n    for h in thread_handles {\n        h.join().ok()\n    }\n}\n\n// Main game loop with fixed timestep and threading\nfunc main() -> () or Error {\n    // Thread pool for CPU-bound physics work\n    with threading(4) {\n        let state = try GameState.new()\n\n        const target_fps = 60.0f32\n        const dt = 1.0f32 / target_fps\n        const NUM_PHYSICS_THREADS: usize = 4u64\n\n        let last_time = 0.0f32  // Simplified: track elapsed time\n        let accumulator = 0.0f32\n        let spawn_timer = 0.0f32\n        let frame_count = 0\n\n        println(\"Game started! Score: 0\")\n\n        // Simulate game for a few seconds\n        while !state.game_over && frame_count < 300 {\n            // Simulate frame time (16ms = ~60fps)\n            const frame_time = 0.016f32\n            last_time += frame_time\n\n            accumulator += frame_time\n\n            // Fixed timestep updates\n            while accumulator >= dt {\n                // Handle input (simulated - would be real input in actual game)\n                if frame_count % 30 == 0 {\n                    // Fire projectile\n                    if state.player is Some(player_h) {\n                        const px = state.entities[player_h].position.x\n                        const py = state.entities[player_h].position.y\n                        try state.spawn_projectile(px + 20.0f32, py, 300.0f32, 0.0f32)\n                    }\n                }\n\n                // Parallel physics: split entity updates across thread pool\n                // Each thread processes a batch of entities\n                parallel_movement_system(state, dt, NUM_PHYSICS_THREADS)\n\n                // Collision runs single-threaded (needs to see all entities)\n                collision_system(state)\n\n                // Game logic on main thread\n                spawn_timer = spawn_system(state, spawn_timer + dt)\n                cleanup_system(state)\n\n                accumulator -= dt\n            }\n\n            // Render (simulated - just print status occasionally)\n            if frame_count % 60 == 0 {\n                const entity_count = state.entities.len()\n                let player_health = 0\n                if state.player is Some(h) {\n                    player_health = state.entities[h].health.current\n                }\n                println(\"Frame {frame_count}: Entities={entity_count}, Health={player_health}, Score={state.score}\")\n            }\n\n            frame_count += 1\n\n            // In a real game, we'd sleep here to maintain frame rate\n            // time.sleep(time.Duration.from_millis(16))\n        }\n\n        if state.game_over {\n            println(\"Game Over! Final Score: {state.score}\")\n        } else {\n            println(\"Demo complete! Final Score: {state.score}\")\n        }\n    }\n\n    return Result.Ok(())\n}\n",
    "grep_clone": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// grep clone - Pattern Search CLI Tool\n// Demonstrates: CLI args, file I/O, string operations, iteration, error handling\n\nimport fs\nimport cli\nimport std\n\nstruct Options {\n    pattern: string\n    files: Vec<string>\n    ignore_case: bool\n    line_numbers: bool\n    count_only: bool\n    invert_match: bool\n}\n\nenum GrepError {\n    NoPattern,\n    NoFiles,\n    FileError(string),\n}\n\nextend GrepError {\n    func message(self) -> string {\n        match self {\n            NoPattern => return \"missing pattern argument\",\n            NoFiles => return \"no files specified\",\n            FileError(msg) => return \"{msg}\",\n        }\n    }\n}\n\nfunc parse_args(args: Vec<string>) -> Options or GrepError {\n    let opts = Options {\n        pattern: \"\",\n        files: Vec.new(),\n        ignore_case: false,\n        line_numbers: false,\n        count_only: false,\n        invert_match: false,\n    }\n\n    let positional = Vec.new()\n\n    for arg in args.iter().skip(1) {\n        match arg {\n            \"-i\" => opts.ignore_case = true,\n            \"-n\" => opts.line_numbers = true,\n            \"-c\" => opts.count_only = true,\n            \"-v\" => opts.invert_match = true,\n            \"-h\" | \"--help\" => {\n                print_usage()\n                std.exit(0)\n            }\n            \"--\" => {}  // Skip arg delimiter\n            _ => positional.push(arg.clone()),\n        }\n    }\n\n    if positional.len() == 0: return Err(GrepError.NoPattern)\n    opts.pattern = positional[0].clone()\n\n    // Collect remaining positional args as files\n    if positional.len() == 1: return Err(GrepError.NoFiles)\n    let i = 1\n    while i < positional.len() {\n        opts.files.push(positional[i].clone())\n        i = i + 1\n    }\n\n    return Ok(opts)\n}\n\nfunc print_usage() {\n    println(\"Usage: rgrep [OPTIONS] PATTERN FILE...\")\n    println(\"\")\n    println(\"Options:\")\n    println(\"  -i    Ignore case\")\n    println(\"  -n    Show line numbers\")\n    println(\"  -c    Count matching lines only\")\n    println(\"  -v    Invert match (show non-matching lines)\")\n    println(\"  -h    Show this help\")\n}\n\nfunc line_matches(line: string, pattern: string, ignore_case: bool) -> bool {\n    if ignore_case {\n        const lower_line = line.to_lowercase()\n        const lower_pattern = pattern.to_lowercase()\n        return lower_line.contains(lower_pattern)\n    } else {\n        return line.contains(pattern)\n    }\n}\n\nfunc grep_file(path: string, opts: Options) -> i64 or GrepError {\n    const content = try fs.read_file(path.clone())\n        .map_err(|e| GrepError.FileError(e))\n\n    const lines = content.lines()\n    let match_count: i64 = 0\n    let line_num = 0\n\n    for line in lines {\n        line_num = line_num + 1\n        const matches = line_matches(line.clone(), opts.pattern.clone(), opts.ignore_case)\n        const show = if opts.invert_match: !matches else: matches\n\n        if show {\n            match_count = match_count + 1\n\n            if !opts.count_only {\n                if opts.line_numbers {\n                    println(\"{line_num}:{line}\")\n                } else {\n                    println(\"{line}\")\n                }\n            }\n        }\n    }\n\n    if opts.count_only {\n        println(\"{match_count}\")\n    }\n\n    return Ok(match_count)\n}\n\nfunc main() {\n    const args = cli.args()\n    const opts = match parse_args(args) {\n        Ok(o) => o,\n        Err(e) => {\n            const msg = e.message()\n            println(\"rgrep: {msg}\")\n            print_usage()\n            std.exit(1)\n        }\n    }\n\n    let total_matches = 0\n    let had_errors = false\n\n    for file_path in opts.files.clone() {\n        match grep_file(file_path, opts.clone()) {\n            Ok(count) => total_matches = total_matches + count,\n            Err(e) => {\n                const msg = e.message()\n                println(\"rgrep: {msg}\")\n                had_errors = true\n            }\n        }\n    }\n\n    if had_errors: std.exit(2)\n    if total_matches == 0: std.exit(1)\n}\n",
    "hello_world": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\nfunc main() {\n    println(\"Hello, World!\")\n}\n",
    "http_api_server": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// HTTP JSON API Server\n// Demonstrates: Concurrency (spawn, channels), JSON, error handling, with multitasking\n\nimport net\nimport json\nimport time\n\n// User data stored in memory\nstruct User {\n    public id: i64\n    public name: string\n    public email: string\n}\n\n// API request/response types\nstruct CreateUserRequest {\n    name: string\n    email: string\n}\n\nstruct UserResponse {\n    id: i64\n    name: string\n    email: string\n}\n\nstruct ErrorResponse {\n    error: string\n}\n\n// Log entry for request logging via channel\nstruct LogEntry {\n    timestamp: time.Instant\n    method: string\n    path: string\n    status: i32\n    duration_ms: f64\n}\n\n// Simple in-memory database using Shared for concurrent access\nstruct Database {\n    users: Map<i64, User>\n    next_id: i64\n}\n\nextend Database {\n    func new() -> Database {\n        Database {\n            users: Map.new(),\n            next_id: 1,\n        }\n    }\n}\n\n// Handle a single HTTP request with logging\nfunc handle_request(\n    conn: TcpConnection,\n    db: Shared<Database>,\n    log_tx: Sender<LogEntry>\n) -> () or Error {\n    const start = time.Instant.now()\n    const request = try conn.read_http_request()\n\n    const response = match (request.method, request.path) {\n        (\"GET\", \"/users\") => list_users(db),\n        (\"GET\", path) if path.starts_with(\"/users/\") => {\n            const id = try path[7..].parse<i64>()\n            get_user(db, id)\n        }\n        (\"POST\", \"/users\") => create_user(db, request.body),\n        (\"DELETE\", path) if path.starts_with(\"/users/\") => {\n            const id = try path[7..].parse<i64>()\n            delete_user(db, id)\n        }\n        _ => http_response(404, json.encode(ErrorResponse { error: \"Not found\" })),\n    }\n\n    try conn.write_http_response(response)\n\n    // Send log entry through channel (non-blocking with buffered channel)\n    try log_tx.send(LogEntry {\n        timestamp: start,\n        method: request.method,\n        path: request.path,\n        status: response.status,\n        duration_ms: start.elapsed().as_secs_f64() * 1000.0,\n    })\n\n    Ok(())\n}\n\nfunc list_users(db: Shared<Database>) -> HttpResponse {\n    const users = db.read(|d| {\n        d.users.values().map(|u| UserResponse {\n            id: u.id,\n            name: u.name.clone(),\n            email: u.email.clone(),\n        }).collect()\n    })\n    http_response(200, json.encode(users))\n}\n\nfunc get_user(db: Shared<Database>, id: i64) -> HttpResponse {\n    const user = db.read(|d| d.users.get(id).map(|u| UserResponse {\n        id: u.id,\n        name: u.name.clone(),\n        email: u.email.clone(),\n    }))\n\n    match user {\n        Some(u) => http_response(200, json.encode(u)),\n        None => http_response(404, json.encode(ErrorResponse { error: \"User not found\" })),\n    }\n}\n\nfunc create_user(db: Shared<Database>, body: string) -> HttpResponse {\n    const req = match json.decode<CreateUserRequest>(body) {\n        Ok(r) => r,\n        Err(e) => return http_response(400, json.encode(ErrorResponse {\n            error: \"Invalid JSON: {e}\"\n        })),\n    }\n\n    const user = db.write(|d| {\n        const id = d.next_id\n        d.next_id += 1\n        const user = User { id: id, name: req.name, email: req.email }\n        try d.users.insert(id, user.clone())\n        UserResponse { id: user.id, name: user.name, email: user.email }\n    })\n\n    http_response(201, json.encode(user))\n}\n\nfunc delete_user(db: Shared<Database>, id: i64) -> HttpResponse {\n    const removed = db.write(|d| d.users.remove(id))\n\n    match removed {\n        Some(_) => http_response(204, \"\"),\n        None => http_response(404, json.encode(ErrorResponse { error: \"User not found\" })),\n    }\n}\n\nfunc http_response(status: i32, body: string) -> HttpResponse {\n    HttpResponse {\n        status: status,\n        headers: Map.from([(\"Content-Type\", \"application/json\")]),\n        body: body,\n    }\n}\n\nfunc main() -> () or Error {\n    const db = Shared.new(Database.new())\n\n    // Create buffered channel for request logging\n    let (log_tx, log_rx) = Channel<LogEntry>.buffered(100)\n\n    with multitasking {\n        // Spawn logger task that consumes log entries\n        spawn {\n            while log_rx.recv() is Ok(entry) {\n                const elapsed = entry.timestamp.elapsed().as_secs_f64()\n                println(\"[{elapsed:.3}s] {entry.method} {entry.path} -> {entry.status} ({entry.duration_ms:.2}ms)\")\n            }\n        }.detach()\n\n        const listener = try net.tcp_listen(\"0.0.0.0:8080\")\n        println(\"Server listening on :8080\")\n\n        loop {\n            const conn = try listener.accept()\n            const db_ref = db.clone()\n            const log_tx_ref = log_tx.clone()\n\n            // Spawn a green task for each connection\n            spawn {\n                match handle_request(conn, db_ref, log_tx_ref) {\n                    Ok(()) => {}\n                    Err(e) => println(\"Request error: {e}\"),\n                }\n            }.detach()\n        }\n    }\n}\n",
    "pool_test": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\nstruct Entity {\n    name: string\n    health: i32\n    active: bool\n}\n\nfunc main() -> () or string {\n    // Basic pool operations\n    const pool = Pool.new()\n\n    const h1 = try pool.insert(Entity { name: \"Alice\", health: 100, active: true })\n    const h2 = try pool.insert(Entity { name: \"Bob\", health: 80, active: true })\n    const h3 = try pool.insert(Entity { name: \"Charlie\", health: 60, active: true })\n\n    const len = pool.len()\n    println(\"Pool length: {len}\")\n    const is_empty = pool.is_empty()\n    println(\"Is empty: {is_empty}\")\n\n    // Index access - read whole value\n    const e1 = pool[h1]\n    println(\"Entity 1: {e1.name}\")\n\n    // Index access - read field\n    const name2 = pool[h2].name\n    const health2 = pool[h2].health\n    println(\"Entity 2: {name2}, health={health2}\")\n\n    // Field assignment via index\n    pool[h1].health = 90\n    const h1_health = pool[h1].health\n    println(\"After assignment: h1 health={h1_health}\")\n\n    // Compound assignment (pool[h].field -= value)\n    pool[h2].health -= 20\n    const h2_health = pool[h2].health\n    println(\"After compound assign: h2 health={h2_health}\")\n\n    // Contains check\n    const c1 = pool.contains(h1)\n    const c3 = pool.contains(h3)\n    println(\"Contains h1: {c1}\")\n    println(\"Contains h3: {c3}\")\n\n    // Remove\n    pool.remove(h3)\n    const len2 = pool.len()\n    println(\"Pool length after remove: {len2}\")\n    const c3_after = pool.contains(h3)\n    println(\"Contains h3 after remove: {c3_after}\")\n\n    // Safe get on valid handle\n    const maybe = pool.get(h1)\n    if maybe is Some(entity) {\n        println(\"Got h1: {entity.name}\")\n    }\n\n    // Safe get on stale handle (should be None)\n    const stale = pool.get(h3)\n    if stale is None {\n        println(\"Correctly got None for stale handle\")\n    }\n\n    // Iteration via cursor\n    println(\"All entities via cursor:\")\n    for h in pool.cursor() {\n        const e = pool[h]\n        println(\"  {e.name}: health={e.health}\")\n    }\n\n    // Insert more entities to test slot reuse\n    const h4 = try pool.insert(Entity { name: \"Diana\", health: 70, active: true })\n    const len3 = pool.len()\n    println(\"After inserting Diana, pool length: {len3}\")\n\n    // Safe removal during iteration\n    pool[h4].health = 30\n    for h in pool.cursor() {\n        const e = pool[h]\n        if e.health < 50 {\n            pool.remove(h)\n        }\n    }\n    const len4 = pool.len()\n    println(\"Pool length after cleanup: {len4}\")\n\n    // Verify remaining entities\n    println(\"Remaining entities:\")\n    for h in pool.cursor() {\n        const e = pool[h]\n        println(\"  {e.name}: health={e.health}\")\n    }\n\n    println(\"Pool test passed!\")\n    Ok(())\n}\n",
    "sensor_processor": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Embedded Sensor Processor\n// Demonstrates: Lock-free atomics, unsafe hardware access, hard real-time deadlines,\n//               zero-allocation hot paths, interrupt handling, generics, SIMD\n\nimport time\n\n// ============================================================================\n// Lock-free SPSC (Single Producer Single Consumer) Ring Buffer\n// Used for interrupt handler → main loop communication without locks\n// ============================================================================\n\nstruct SpscRingBuffer<T, const N: usize> {\n    data: [T; N]\n    write_idx: Atomic<usize>  // Written by producer (interrupt)\n    read_idx: Atomic<usize>   // Written by consumer (main loop)\n}\n\nextend SpscRingBuffer<T, N> {\n    func new(default: T) -> SpscRingBuffer<T, N> {\n        SpscRingBuffer {\n            data: [default; N],\n            write_idx: Atomic.new(0),\n            read_idx: Atomic.new(0),\n        }\n    }\n\n    // Called from interrupt context - must be lock-free and allocation-free\n    @no_alloc\n    func try_push(self, value: T) -> bool {\n        const write = self.write_idx.load(Ordering.Relaxed)\n        const next_write = (write + 1) % N\n\n        // Check if full (would overwrite unread data)\n        if next_write == self.read_idx.load(Ordering.Acquire) {\n            return false  // Buffer full, drop sample\n        }\n\n        self.data[write] = value\n        self.write_idx.store(next_write, Ordering.Release)\n        true\n    }\n\n    // Called from main loop - allocation-free for real-time safety\n    @no_alloc\n    func try_pop(self) -> T? {\n        const read = self.read_idx.load(Ordering.Relaxed)\n        const write = self.write_idx.load(Ordering.Acquire)\n\n        if read == write {\n            return None  // Buffer empty\n        }\n\n        const value = self.data[read]\n        self.read_idx.store((read + 1) % N, Ordering.Release)\n        Some(value)\n    }\n\n    func len(self) -> usize {\n        const write = self.write_idx.load(Ordering.Acquire)\n        const read = self.read_idx.load(Ordering.Acquire)\n        if write >= read { write - read } else { N - read + write }\n    }\n}\n\n// ============================================================================\n// Sensor Reading with Timestamp (for latency measurement)\n// ============================================================================\n\nstruct SensorReading {\n    sensor_id: u8\n    value: f32\n    timestamp_ns: u64  // Nanoseconds since start\n}\n\n// ============================================================================\n// Simulated Hardware Registers (demonstrates unsafe)\n// In real embedded, these would be memory-mapped I/O addresses\n// ============================================================================\n\nconst SENSOR_BASE_ADDR: usize = 0x4000_0000\n\n// ============================================================================\n// Compile-Time Lookup Tables (demonstrates comptime)\n// Generated at compile time, embedded in binary - zero runtime cost\n// ============================================================================\n\n// CRC-8 lookup table for packet validation (polynomial 0x07)\ncomptime func build_crc8_table() -> [u8; 256] {\n    const table = [0u8; 256]\n    for i in 0..256 {\n        let crc = i as u8\n        for _ in 0..8 {\n            if crc & 0x80 != 0 {\n                crc = (crc << 1) ^ 0x07\n            } else {\n                crc = crc << 1\n            }\n        }\n        table[i] = crc\n    }\n    table\n}\n\nconst CRC8_TABLE: [u8; 256] = comptime build_crc8_table()\n\n// ADC value to temperature conversion (10-bit ADC, -40°C to +125°C range)\n// Pre-computed to avoid floating point in interrupt context\ncomptime func build_temp_calibration() -> [i16; 1024] {\n    const table = [0i16; 1024]\n    for adc in 0..1024 {\n        // Linear mapping: ADC 0 = -40.00°C, ADC 1023 = +125.00°C\n        // Stored as centidegrees (×100) for integer math\n        const temp_centidegrees = -4000 + (adc * 16500) / 1023\n        table[adc] = temp_centidegrees as i16\n    }\n    table\n}\n\nconst TEMP_CALIBRATION: [i16; 1024] = comptime build_temp_calibration()\n\n// Sensor command opcodes - compile-time map for protocol parsing\ncomptime func build_command_table() -> [u8; 256] {\n    // Maps ASCII command bytes to opcode constants\n    // 0 = invalid, 1 = read, 2 = write, 3 = reset, 4 = calibrate\n    const table = [0u8; 256]\n    table['R' as usize] = 1  // Read\n    table['r' as usize] = 1\n    table['W' as usize] = 2  // Write\n    table['w' as usize] = 2\n    table['X' as usize] = 3  // Reset\n    table['x' as usize] = 3\n    table['C' as usize] = 4  // Calibrate\n    table['c' as usize] = 4\n    table\n}\n\nconst COMMAND_OPCODES: [u8; 256] = comptime build_command_table()\n\n// CRC-8 computation using pre-computed table - runs in interrupt context\n@inline @no_alloc\nfunc crc8(data: []u8) -> u8 {\n    let crc = 0u8\n    for byte in data {\n        crc = CRC8_TABLE[(crc ^ byte) as usize]\n    }\n    crc\n}\n\n// Convert raw ADC reading to temperature (centidegrees) - no FP, O(1)\n@inline @no_alloc\nfunc adc_to_temp(adc_value: u16) -> i16 {\n    TEMP_CALIBRATION[adc_value.min(1023) as usize]\n}\n\n// Parse command byte to opcode - O(1) lookup\n@inline @no_alloc\nfunc parse_command(cmd: u8) -> u8 {\n    COMMAND_OPCODES[cmd as usize]\n}\n\nstruct HardwareRegisters {\n    temp_data: u32      // offset 0x00\n    pressure_data: u32  // offset 0x04\n    humidity_data: u32  // offset 0x08\n    status: u32         // offset 0x0C\n    control: u32        // offset 0x10\n}\n\n// Read from simulated hardware register\nfunc read_hardware_sensor(sensor_id: u8, tick: u64) -> f32 {\n    // In real embedded code, this would be:\n    // unsafe {\n    //     const regs = SENSOR_BASE_ADDR as *const HardwareRegisters\n    //     match sensor_id {\n    //         0 => (*regs).temp_data as f32 / 100.0,\n    //         1 => (*regs).pressure_data as f32 / 10.0,\n    //         2 => (*regs).humidity_data as f32 / 100.0,\n    //         _ => 0.0,\n    //     }\n    // }\n\n    // Simulated sensor values with realistic noise\n    const base = match sensor_id {\n        0 => 2200,   // Temperature: 22.00°C base\n        1 => 10130,  // Pressure: 1013.0 hPa base\n        2 => 4500,   // Humidity: 45.00% base\n        _ => 0,\n    }\n\n    // Deterministic \"noise\" based on tick (simulates ADC noise)\n    const noise = ((tick * 7 + sensor_id as u64 * 13) % 100) as i32 - 50\n    (base + noise) as f32 / 100.0\n}\n\n// ============================================================================\n// Timing Statistics with Jitter Analysis\n// ============================================================================\n\nstruct TimingStats {\n    samples: [u64; 256]     // Fixed buffer for cycle times\n    sample_idx: usize\n    sample_count: usize\n    min_ns: u64\n    max_ns: u64\n    sum_ns: u64\n    sum_squared_ns: u128    // For variance calculation\n    deadline_misses: u64\n}\n\nextend TimingStats {\n    func new() -> TimingStats {\n        TimingStats {\n            samples: [0u64; 256],\n            sample_idx: 0,\n            sample_count: 0,\n            min_ns: u64.MAX,\n            max_ns: 0,\n            sum_ns: 0,\n            sum_squared_ns: 0,\n            deadline_misses: 0,\n        }\n    }\n\n    // Record a cycle time - O(1), no allocation\n    @no_alloc\n    func record(self, cycle_ns: u64, deadline_ns: u64) {\n        // Update rolling buffer\n        self.samples[self.sample_idx] = cycle_ns\n        self.sample_idx = (self.sample_idx + 1) % 256\n\n        // Update statistics\n        if self.sample_count < 256 {\n            self.sample_count += 1\n        }\n        if cycle_ns < self.min_ns: self.min_ns = cycle_ns\n        if cycle_ns > self.max_ns: self.max_ns = cycle_ns\n        self.sum_ns += cycle_ns\n        self.sum_squared_ns += (cycle_ns as u128) * (cycle_ns as u128)\n\n        if cycle_ns > deadline_ns {\n            self.deadline_misses += 1\n        }\n    }\n\n    func mean_ns(self) -> u64 {\n        if self.sample_count == 0: return 0\n        self.sum_ns / self.sample_count as u64\n    }\n\n    // Jitter = standard deviation of cycle times\n    func jitter_ns(self) -> u64 {\n        if self.sample_count < 2: return 0\n        const n = self.sample_count as u128\n        const mean = self.sum_ns as u128 / n\n        const variance = (self.sum_squared_ns / n) - (mean * mean)\n        // Integer sqrt approximation\n        isqrt(variance) as u64\n    }\n}\n\n// Integer square root (no floating point in hot path)\n@no_alloc\nfunc isqrt(n: u128) -> u128 {\n    if n == 0: return 0\n    let x = n\n    let y = (x + 1) / 2\n    while y < x {\n        x = y\n        y = (x + n / x) / 2\n    }\n    x\n}\n\n// ============================================================================\n// Interrupt Handler Simulation (runs on separate thread)\n// ============================================================================\n\n@no_alloc\nfunc interrupt_handler(\n    buffer: SpscRingBuffer<SensorReading, 256>,\n    start_time: time.Instant,\n    running: Atomic<bool>,\n    sample_rate_hz: u32\n) {\n    const period_ns = 1_000_000_000u64 / sample_rate_hz as u64\n    let next_sample_time = start_time\n    let sequence: u64 = 0\n\n    while running.load(Ordering.Relaxed) {\n        // Spin-wait until sample time (simulates hardware timer interrupt)\n        while time.Instant.now().duration_since(start_time).as_nanos() <\n              next_sample_time.duration_since(start_time).as_nanos() {\n            // Spin - in real embedded this would be WFI (wait for interrupt)\n            core.hint.spin_loop()\n        }\n\n        const now_ns = time.Instant.now().duration_since(start_time).as_nanos()\n\n        // Read all sensors and push to lock-free buffer\n        for sensor_id in 0u8..3u8 {\n            const reading = SensorReading {\n                sensor_id: sensor_id,\n                value: read_hardware_sensor(sensor_id, sequence),\n                timestamp_ns: now_ns,\n            }\n\n            if !buffer.try_push(reading) {\n                // Buffer overflow - in real system would set error flag\n                // Cannot print here (interrupt context)\n            }\n        }\n\n        sequence += 1\n        next_sample_time = start_time + time.Duration.from_nanos(period_ns * sequence)\n    }\n}\n\n// ============================================================================\n// Main Processing Loop\n// ============================================================================\n\nstruct ProcessorState {\n    // Circular buffers for each sensor (no allocation after init)\n    temp_history: [f32; 64]\n    pressure_history: [f32; 64]\n    humidity_history: [f32; 64]\n    history_idx: usize\n    history_count: usize\n\n    // Processed outputs\n    temp_avg: f32\n    pressure_avg: f32\n    humidity_avg: f32\n\n    // Counters\n    samples_processed: u64\n    buffer_overflows: u64\n}\n\nextend ProcessorState {\n    func new() -> ProcessorState {\n        ProcessorState {\n            temp_history: [0.0f32; 64],\n            pressure_history: [0.0f32; 64],\n            humidity_history: [0.0f32; 64],\n            history_idx: 0,\n            history_count: 0,\n            temp_avg: 0.0,\n            pressure_avg: 0.0,\n            humidity_avg: 0.0,\n            samples_processed: 0,\n            buffer_overflows: 0,\n        }\n    }\n\n    // Process a single reading - must complete in bounded time\n    @inline @no_alloc\n    func process_reading(self, reading: SensorReading) {\n        // Store in appropriate history buffer\n        match reading.sensor_id {\n            0 => self.temp_history[self.history_idx] = reading.value,\n            1 => self.pressure_history[self.history_idx] = reading.value,\n            2 => self.humidity_history[self.history_idx] = reading.value,\n            _ => {}\n        }\n\n        // Update index only after all sensors for this tick\n        if reading.sensor_id == 2 {\n            self.history_idx = (self.history_idx + 1) % 64\n            if self.history_count < 64 {\n                self.history_count += 1\n            }\n        }\n\n        self.samples_processed += 1\n    }\n\n    // Compute averages using SIMD for vectorized summation\n    // 64-element arrays = 8 iterations of f32x8 (256-bit SIMD)\n    @no_alloc\n    func compute_averages(self) {\n        if self.history_count == 0: return\n\n        // Use SIMD to sum arrays in parallel\n        // Process 8 floats at a time using f32x8 (AVX on x86, NEON on ARM)\n        const temp_sum = simd_sum_f32(self.temp_history, self.history_count)\n        const pressure_sum = simd_sum_f32(self.pressure_history, self.history_count)\n        const humidity_sum = simd_sum_f32(self.humidity_history, self.history_count)\n\n        const n = self.history_count as f32\n        self.temp_avg = temp_sum / n\n        self.pressure_avg = pressure_sum / n\n        self.humidity_avg = humidity_sum / n\n    }\n}\n\n// SIMD-optimized array sum using 8-wide vectors\n// Processes 8 f32 values per iteration (AVX-256 / NEON)\n@no_alloc @inline\nfunc simd_sum_f32(data: [f32; 64], count: usize) -> f32 {\n    // Accumulator vector - 8 parallel sums\n    let acc: f32x8 = [0.0; 8]\n\n    // Process full 8-element chunks\n    const full_chunks = count / 8\n    for i in 0..full_chunks {\n        // Load 8 contiguous floats directly into SIMD register\n        // Compiles to single VMOVUPS (AVX) or VLD1 (NEON) instruction\n        const chunk = f32x8.load(data[i * 8..])\n        acc = acc + chunk\n    }\n\n    // Horizontal sum: reduce 8 lanes to single value\n    let sum = acc.sum()\n\n    // Handle remaining elements (count % 8)\n    const remainder_start = full_chunks * 8\n    for i in remainder_start..count {\n        sum += data[i]\n    }\n\n    sum\n}\n\n// ============================================================================\n// Main Entry Point\n// ============================================================================\nfunc main() -> () or Error {\n    println(\"=== Real-Time Sensor Processor ===\")\n    println(\"\")\n\n    // Configuration\n    const SAMPLE_RATE_HZ: u32 = 1000        // 1kHz sensor sampling\n    const PROCESS_RATE_HZ: u32 = 100        // 100Hz processing loop\n    const HARD_DEADLINE_US: u64 = 5000      // 5ms hard deadline (50% of period)\n    const DURATION_SECS: u64 = 2            // Run for 2 seconds\n\n    println(\"Sample rate: {SAMPLE_RATE_HZ} Hz (interrupt)\")\n    println(\"Process rate: {PROCESS_RATE_HZ} Hz (main loop)\")\n    println(\"Hard deadline: {HARD_DEADLINE_US} µs\")\n    println(\"\")\n\n    // Pre-allocate everything before real-time section\n    let buffer = SpscRingBuffer<SensorReading, 256>.new(SensorReading {\n        sensor_id: 0,\n        value: 0.0,\n        timestamp_ns: 0,\n    })\n    let state = ProcessorState.new()\n    let timing = TimingStats.new()\n    let running = Atomic.new(true)\n\n    const start_time = time.Instant.now()\n    const process_period_ns = 1_000_000_000u64 / PROCESS_RATE_HZ as u64\n    const deadline_ns = HARD_DEADLINE_US * 1000\n\n    // Start interrupt handler on raw thread (needs thread affinity)\n    let isr_handle = spawn_raw {\n        interrupt_handler(buffer, start_time, running, SAMPLE_RATE_HZ)\n    }\n\n    println(\"Started. Processing for {DURATION_SECS} seconds...\")\n    println(\"\")\n\n    // === REAL-TIME SECTION - NO ALLOCATIONS BELOW THIS LINE ===\n\n    let cycle: u64 = 0\n    let next_process_time = start_time\n\n    while time.Instant.now().duration_since(start_time).as_secs() < DURATION_SECS {\n        const cycle_start = time.Instant.now()\n\n        // Drain all available samples from interrupt buffer\n        let drained: u32 = 0\n        while buffer.try_pop() is Some(reading) {\n            state.process_reading(reading)\n            drained += 1\n        }\n\n        // Compute derived values (less frequent)\n        if cycle % 10 == 0 {\n            state.compute_averages()\n        }\n\n        // Measure cycle time\n        const cycle_ns = cycle_start.elapsed().as_nanos()\n        timing.record(cycle_ns, deadline_ns)\n\n        // HARD DEADLINE CHECK - would panic in production\n        if cycle_ns > deadline_ns {\n            // In safety-critical system: trigger watchdog, enter safe mode\n            // Here we just count it\n        }\n\n        cycle += 1\n\n        // Spin-wait for next cycle (more precise than sleep)\n        next_process_time = start_time + time.Duration.from_nanos(process_period_ns * cycle)\n        while time.Instant.now() < next_process_time {\n            core.hint.spin_loop()\n        }\n    }\n\n    // === END REAL-TIME SECTION ===\n\n    // Signal interrupt handler to stop\n    running.store(false, Ordering.Release)\n    try isr_handle.join()\n\n    // Print results\n    println(\"=== Results ===\")\n    println(\"\")\n    println(\"Samples processed: {state.samples_processed}\")\n    println(\"Processing cycles: {cycle}\")\n    println(\"\")\n    println(\"Timing Statistics:\")\n    println(\"  Min cycle:  {timing.min_ns / 1000} µs\")\n    println(\"  Max cycle:  {timing.max_ns / 1000} µs\")\n    println(\"  Mean cycle: {timing.mean_ns() / 1000} µs\")\n    println(\"  Jitter:     {timing.jitter_ns() / 1000} µs (std dev)\")\n    println(\"  Deadline misses: {timing.deadline_misses}\")\n    println(\"\")\n    println(\"Final Averages (64-sample window):\")\n    println(\"  Temperature: {state.temp_avg:.2} °C\")\n    println(\"  Pressure:    {state.pressure_avg:.1} hPa\")\n    println(\"  Humidity:    {state.humidity_avg:.1} %\")\n\n    if timing.deadline_misses > 0 {\n        println(\"\")\n        println(\"WARNING: {timing.deadline_misses} deadline misses detected!\")\n    }\n\n    Ok(())\n}\n",
    "simple_grep": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Simple grep - Pattern search using module syntax\n// Usage: rask run simple_grep.rk <pattern> <file>\n// Demonstrates: cli.args, fs.read_lines, string methods, match, Vec, loops\n\nimport fs\nimport cli\nimport std\n\nenum GrepResult {\n    Ok(i32)\n    Err(string)\n}\n\nfunc grep_file(pattern: string, path: string) -> GrepResult {\n    const lines_result = fs.read_lines(path)\n\n    match lines_result {\n        Ok(lines) => {\n            let match_count = 0\n            let line_num = 0\n\n            for line in lines {\n                line_num = line_num + 1\n                if line.contains(pattern) {\n                    match_count = match_count + 1\n                    println(\"{line_num}: {line}\")\n                }\n            }\n\n            return GrepResult.Ok(match_count)\n        }\n        Err(e) => return GrepResult.Err(e)\n    }\n}\n\nfunc main() {\n    const args = cli.args()\n    const argc = args.len()\n\n    if argc < 3 {\n        println(\"Usage: rask run simple_grep.rk <pattern> <file>\")\n        std.exit(1)\n    }\n\n    const pattern = args.get(1)\n    const file_path = args.get(2)\n\n    println(\"Searching for '{pattern}' in {file_path}...\")\n\n    const result = grep_file(pattern, file_path)\n\n    match result {\n        Ok(count) => {\n            println(\"\")\n            println(\"Found {count} matching lines\")\n            if count == 0 {\n                std.exit(1)\n            }\n        }\n        Err(e) => {\n            println(\"Error: {e}\")\n            std.exit(2)\n        }\n    }\n}\n",
    "simple_test": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Simple test file for parser testing\n\nfunc add(a: i32, b: i32) -> i32 {\n    return a + b\n}\n\nfunc greet(name: string) {\n    println(\"Hello, {name}\")\n}\n\nstruct Point {\n    x: i32\n    y: i32\n}\n\nfunc main() {\n    const x = 10\n    const y = 20\n    const result = add(x, y)\n    println(\"Result: {result}\")\n}\n",
    "text_editor": "// SPDX-License-Identifier: (MIT OR Apache-2.0)\n// Text Editor with Undo\n// Demonstrates: Pool/Handle pattern, linear resource types, ensure cleanup, command pattern\n\nimport fs\nimport io\n\n// A line in the document\nstruct Line {\n    text: string\n}\n\n// Edit commands that can be undone\nenum EditCommand {\n    InsertLine(after: i32, text: string),\n    DeleteLine(at: i32, deleted_text: string),\n    ModifyLine(at: i32, old_text: string, new_text: string),\n}\n\nextend EditCommand {\n    // Create the inverse command for undo\n    func inverse(self) -> EditCommand {\n        return match self {\n            InsertLine(after, text) => EditCommand.DeleteLine(at: after + 1, deleted_text: text),\n            DeleteLine(at, deleted_text) => EditCommand.InsertLine(after: at - 1, text: deleted_text),\n            ModifyLine(at, old_text, new_text) => EditCommand.ModifyLine(at: at, old_text: new_text, new_text: old_text),\n        }\n    }\n}\n\n// The document model\nstruct Document {\n    lines: Pool<Line>\n    line_order: Vec<Handle<Line>>  // Maintains line ordering\n    undo_stack: Vec<EditCommand>\n    redo_stack: Vec<EditCommand>\n    modified: bool\n}\n\nextend Document {\n    func new() -> Document {\n        return Document {\n            lines: Pool.new(),\n            line_order: Vec.new(),\n            undo_stack: Vec.new(),\n            redo_stack: Vec.new(),\n            modified: false,\n        }\n    }\n\n    func from_file(path: string) -> Document or fs.IoError {\n        const file = try fs.open(path)\n        ensure file.close()\n\n        let doc = Document.new()\n        for line in file.lines() {\n            const text = try line\n            const h = try doc.lines.insert(Line { text: text })\n            try doc.line_order.push(h)\n        }\n        Ok(doc)\n    }\n\n    func line_count(self) -> i32 {\n        return self.line_order.len() as i32\n    }\n\n    func get_line(self, index: i32) -> Option<string> {\n        if index < 0 || index >= self.line_count(): return None\n        const h = self.line_order[index as usize]\n        return Some(self.lines[h].text.clone())\n    }\n\n    // Insert a new line after the given index (-1 for beginning)\n    func insert_line(self, after: i32, text: string) -> () or Error {\n        const h = try self.lines.insert(Line { text: text.clone() })\n        const insert_pos = (after + 1) as usize\n        try self.line_order.insert(insert_pos, h)\n\n        // Record for undo\n        try self.undo_stack.push(EditCommand.InsertLine(after: after, text: text))\n        self.redo_stack.clear()\n        self.modified = true\n    }\n\n    // Delete a line at the given index\n    func delete_line(self, at: i32) -> () or Error {\n        if at < 0 || at >= self.line_count(): return Err(Error.IndexOutOfBounds)\n\n        const h = self.line_order.remove(at as usize)\n        const deleted = self.lines.remove(h).unwrap()\n\n        // Record for undo\n        try self.undo_stack.push(EditCommand.DeleteLine(at: at, deleted_text: deleted.text))\n        self.redo_stack.clear()\n        self.modified = true\n    }\n\n    // Modify text at the given line\n    func modify_line(self, at: i32, new_text: string) -> () or Error {\n        if at < 0 || at >= self.line_count(): return Err(Error.IndexOutOfBounds)\n\n        const h = self.line_order[at as usize]\n        const old_text = self.lines[h].text.clone()\n        self.lines[h].text = new_text.clone()\n\n        // Record for undo\n        try self.undo_stack.push(EditCommand.ModifyLine(at: at, old_text: old_text, new_text: new_text))\n        self.redo_stack.clear()\n        self.modified = true\n    }\n\n    // Undo the last edit\n    func undo(self) -> bool or Error {\n        const cmd = match self.undo_stack.pop() {\n            Some(c) => c,\n            None => return Ok(false),\n        }\n\n        // Apply inverse without recording to undo stack\n        try self.apply_command_silent(cmd.inverse())\n        try self.redo_stack.push(cmd)\n        Ok(true)\n    }\n\n    // Redo the last undone edit\n    func redo(self) -> bool or Error {\n        const cmd = match self.redo_stack.pop() {\n            Some(c) => c,\n            None => return Ok(false),\n        }\n\n        // Apply command without recording to undo stack\n        try self.apply_command_silent(cmd.clone())\n        try self.undo_stack.push(cmd)\n        Ok(true)\n    }\n\n    // Apply a command without recording it\n    func apply_command_silent(self, cmd: EditCommand) -> () or Error {\n        match cmd {\n            InsertLine(after, text) => {\n                const h = try self.lines.insert(Line { text: text })\n                try self.line_order.insert((after + 1) as usize, h)\n            }\n            DeleteLine(at, _) => {\n                const h = self.line_order.remove(at as usize)\n                self.lines.remove(h)\n            }\n            ModifyLine(at, _, new_text) => {\n                const h = self.line_order[at as usize]\n                self.lines[h].text = new_text\n            }\n        }\n        self.modified = true\n    }\n\n    // Save document to file\n    func save(self, path: string) -> () or fs.IoError {\n        const file = try fs.create(path)\n        ensure file.close()\n\n        for h in self.line_order.iter() {\n            try file.write_line(self.lines[h].text)\n        }\n\n        self.modified = false\n        Ok(())\n    }\n\n    // Display the document\n    func display(self) {\n        for i in 0..self.line_count() {\n            const line = self.get_line(i).unwrap()\n            println(\"{i + 1}: {line}\")\n        }\n    }\n}\n\n// Simple command parser for the editor REPL\nenum EditorCommand {\n    Insert(after: i32, text: string),\n    Delete(line: i32),\n    Edit(line: i32, text: string),\n    Undo,\n    Redo,\n    Save(path: string),\n    Print,\n    Quit,\n    Help,\n}\n\nfunc parse_command(input: string) -> Option<EditorCommand> {\n    const parts: Vec<string> = Vec.new()\n    for part in input.trim().split_whitespace() {\n        try parts.push(part.to_owned())\n    }\n    if parts.is_empty(): return None\n\n    return match parts[0] {\n        \"i\" | \"insert\" if parts.len() >= 3 => {\n            const after = try parts[1].parse<i32>().ok()\n            const text = parts[2..].join(\" \")\n            Some(EditorCommand.Insert(after: after, text: text))\n        }\n        \"d\" | \"delete\" if parts.len() >= 2 => {\n            const line = try parts[1].parse<i32>().ok()\n            Some(EditorCommand.Delete(line: line))\n        }\n        \"e\" | \"edit\" if parts.len() >= 3 => {\n            const line = try parts[1].parse<i32>().ok()\n            const text = parts[2..].join(\" \")\n            Some(EditorCommand.Edit(line: line, text: text))\n        }\n        \"u\" | \"undo\" => Some(EditorCommand.Undo),\n        \"r\" | \"redo\" => Some(EditorCommand.Redo),\n        \"w\" | \"save\" if parts.len() >= 2 => Some(EditorCommand.Save(path: parts[1].clone())),\n        \"p\" | \"print\" => Some(EditorCommand.Print),\n        \"q\" | \"quit\" => Some(EditorCommand.Quit),\n        \"h\" | \"help\" => Some(EditorCommand.Help),\n        _ => None,\n    }\n}\n\nfunc print_help() {\n    println(\"Commands:\")\n    println(\"  i/insert <line> <text>  - Insert text after line (0 for beginning)\")\n    println(\"  d/delete <line>         - Delete line\")\n    println(\"  e/edit <line> <text>    - Replace line content\")\n    println(\"  u/undo                  - Undo last change\")\n    println(\"  r/redo                  - Redo last undone change\")\n    println(\"  w/save <path>           - Save to file\")\n    println(\"  p/print                 - Print document\")\n    println(\"  q/quit                  - Quit editor\")\n    println(\"  h/help                  - Show this help\")\n}\n\nfunc main() -> () or Error {\n    let doc = Document.new()\n\n    println(\"Simple Text Editor - type 'help' for commands\")\n\n    loop {\n        print(\"> \")\n        const input = try io.read_line()\n\n        const cmd = match parse_command(input) {\n            Some(c) => c,\n            None => {\n                println(\"Unknown command. Type 'help' for usage.\")\n                continue\n            }\n        }\n\n        match cmd {\n            Insert(after, text) => {\n                try doc.insert_line(after, text)\n                println(\"Inserted line\")\n            }\n            Delete(line) => {\n                try doc.delete_line(line - 1)  // 1-indexed to 0-indexed\n                println(\"Deleted line {line}\")\n            }\n            Edit(line, text) => {\n                try doc.modify_line(line - 1, text)\n                println(\"Modified line {line}\")\n            }\n            Undo => {\n                if try doc.undo(): println(\"Undone\") else: println(\"Nothing to undo\")\n            }\n            Redo => {\n                if try doc.redo(): println(\"Redone\") else: println(\"Nothing to redo\")\n            }\n            Save(path) => {\n                try doc.save(path.clone())\n                println(\"Saved to {path}\")\n            }\n            Print => doc.display(),\n            Quit => {\n                if doc.modified {\n                    println(\"Warning: unsaved changes\")\n                }\n                break\n            }\n            Help => print_help(),\n        }\n    }\n\n    return Ok(())\n}\n"
};

export const EXAMPLE_METADATA = [
    {
        "key": "01_variables",
        "title": "01 Variables",
        "file": "01_variables.rk"
    },
    {
        "key": "02_functions",
        "title": "02 Functions",
        "file": "02_functions.rk"
    },
    {
        "key": "03_collections",
        "title": "03 Collections",
        "file": "03_collections.rk"
    },
    {
        "key": "04_pattern_matching",
        "title": "04 Pattern Matching",
        "file": "04_pattern_matching.rk"
    },
    {
        "key": "05_loops",
        "title": "05 Loops",
        "file": "05_loops.rk"
    },
    {
        "key": "06_structs",
        "title": "06 Structs",
        "file": "06_structs.rk"
    },
    {
        "key": "07_error_handling",
        "title": "07 Error Handling",
        "file": "07_error_handling.rk"
    },
    {
        "key": "cli_calculator",
        "title": "Cli Calculator",
        "file": "cli_calculator.rk"
    },
    {
        "key": "collections_test",
        "title": "Collections Test",
        "file": "collections_test.rk"
    },
    {
        "key": "file_copy",
        "title": "File Copy",
        "file": "file_copy.rk"
    },
    {
        "key": "game_loop",
        "title": "Game Loop",
        "file": "game_loop.rk"
    },
    {
        "key": "grep_clone",
        "title": "Grep Clone",
        "file": "grep_clone.rk"
    },
    {
        "key": "hello_world",
        "title": "Hello World",
        "file": "hello_world.rk"
    },
    {
        "key": "http_api_server",
        "title": "Http Api Server",
        "file": "http_api_server.rk"
    },
    {
        "key": "pool_test",
        "title": "Pool Test",
        "file": "pool_test.rk"
    },
    {
        "key": "sensor_processor",
        "title": "Sensor Processor",
        "file": "sensor_processor.rk"
    },
    {
        "key": "simple_grep",
        "title": "Simple Grep",
        "file": "simple_grep.rk"
    },
    {
        "key": "simple_test",
        "title": "Simple Test",
        "file": "simple_test.rk"
    },
    {
        "key": "text_editor",
        "title": "Text Editor",
        "file": "text_editor.rk"
    }
];

export const DEFAULT_CODE = EXAMPLES.hello_world || `func main() {
    println("Hello, World!")
}`;
